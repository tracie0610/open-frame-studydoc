<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-hans" xml:lang="zh-hans">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/main/misc/favicon.ico" type="image/x-icon" />
 <title>Linux  Shell简介 | LinuxSir.Org</title>
<style type="text/css" media="all">@import "/main/modules/aggregator/aggregator.css";</style>
<style type="text/css" media="all">@import "/main/modules/book/book.css";</style>
<style type="text/css" media="all">@import "/main/modules/codefilter/codefilter.css";</style>
<style type="text/css" media="all">@import "/main/modules/node/node.css";</style>
<style type="text/css" media="all">@import "/main/modules/system/defaults.css";</style>
<style type="text/css" media="all">@import "/main/modules/system/system.css";</style>
<style type="text/css" media="all">@import "/main/modules/user/user.css";</style>
<style type="text/css" media="all">@import "/main/modules/comment/comment.css";</style>
<style type="text/css" media="all">@import "/main/themes/chameleon/marvin/style.css";</style>
<style type="text/css" media="all">@import "/main/themes/chameleon/common.css";</style>
</head><body>
 <div id="header">  <a href="/main/" title="主页"><img src="/main/logo.jpg" alt="主页" /></a></div>
 <div class="navlinks"><ul class="links" id="navlist"><li class="first menu-1-1-116"><a href="/main/" title="首页" class="menu-1-1-116">首页</a></li>
<li class="menu-1-2-116"><a href="/main/taxonomy/term/34" class="menu-1-2-116">事件</a></li>
<li class="menu-1-3-116"><a href="/main/taxonomy/term/1/25/" title="文档" class="menu-1-3-116">文档</a></li>
<li class="menu-1-4-116"><a href="/main/taxonomy/term/35/48/" title="资源" class="menu-1-4-116">资源</a></li>
<li class="menu-1-5-116"><a href="http://www.linuxsir.org/bbs" title="论坛" class="menu-1-5-116">论坛</a></li>
<li class="menu-1-6-116"><a href="/main/taxonomy/term/38" title="贡献者" class="menu-1-6-116">贡献者</a></li>
<li class="menu-1-7-116"><a href="/main/irc.html" title="IRC" class="menu-1-7-116">IRC</a></li>
<li class="menu-1-8-116"><a href="/main/about.html" title="关于" class="menu-1-8-116">关于</a></li>
<li class="last menu-1-9-116"><a href="/main/search.html" title="搜索" class="menu-1-9-116">搜索</a></li>
</ul> </div>
 <table id="content">
  <tr>
   <td id="sidebar-left"><div class="block block-block" id="block-block-3">
 <h2 class="title">重要资讯</h2>
 <div class="content"><ul>
<li><a href="?q=taxonomy/term/36">本站公告</a>
<li><a href="?q=taxonomy/term/34">新闻事件</a>
<li><a href="http://www.linuxsir.org/bbs" target="_blank">本站论坛</a>
<li><a href="?q=taxonomy/term/38">贡 献 者</a>
</ul></div>
</div>
<div class="block block-block" id="block-block-1">
 <h2 class="title">子站索引</h2>
 <div class="content"><ul>
<li><a href="http://fedora.linuxsir.org" target"_blank">Fedora中文</a>
<li><a href="http://debian.linuxsir.org" target"_blank">Debian中文</a>
<li><a href="http://lfs.linuxsir.org" target"_blank">LFS   中文</a>
<li><a href="http://slack.linuxsir.org">Slackware</a>
<li><a href="http://gentoo.linuxsir.org">Gentoo中文</a>
<li><a href="http://arch.linuxsir.org">Arch 中文</a>
</ul>
</div>
</div>
<div class="block block-block" id="block-block-7">
 <h2 class="title">项目索引</h2>
 <div class="content"><ul>
<li><a href="http://www.fcitx.org" target="_blank">小企鹅输入法</a>
<li><a href="http://lumaqq.linuxsir.org" target="_blank">LumaQQ</a>
<li><a href="http://openq.linuxsir.org" target="_blank">OpenQ</a>
<li><a href="http://www.relaxbsd.org" target="_blank">RelaxBSD</a>
</ul>
</div>
</div>
<div class="block block-user" id="block-user-1">
 <h2 class="title">导航</h2>
 <div class="content">
<ul class="menu">
<li class="leaf"><a href="/main/blog" title="我的博客">我的博客</a></li>
<li class="leaf"><a href="/main/user" title="注册/登录">注册/登录</a></li>

</ul>
</div>
</div>
<div class="block block-aggregator" id="block-aggregator-feed-2">
 <h2 class="title">论坛快讯</h2>
 <div class="content"><div class="item-list"><ul><li><a href="http://www.linuxsir.org/bbs/showthread.php?t=335274&amp;goto=newpost">中文文件夹显示的问题</a>
</li><li><a href="http://www.linuxsir.org/bbs/showthread.php?t=335273&amp;goto=newpost">网络管理软件</a>
</li><li><a href="http://www.linuxsir.org/bbs/showthread.php?t=335272&amp;goto=newpost">[help]amule搜索出来的结果是乱码？</a>
</li><li><a href="http://www.linuxsir.org/bbs/showthread.php?t=335271&amp;goto=newpost">各位大虾你们的use值是怎么设置的呀。</a>
</li><li><a href="http://www.linuxsir.org/bbs/showthread.php?t=335270&amp;goto=newpost">請教etch 下mips的交叉編譯環境！！！！</a>
</li></ul></div><div class="more-link"><a href="/main/aggregator/sources/2" title="查看此feed的最新新闻。">更多</a></div></div>
</div>
<div class="block block-user" id="block-user-2">
 <h2 class="title">新进会员</h2>
 <div class="content"><div class="item-list"><ul><li>ciscoshangbin</li><li>qihaubing</li><li>michael_dingtao</li><li>simontao</li><li>owlsky</li></ul></div></div>
</div>
<div class="block block-user" id="block-user-3">
 <h2 class="title">在线用户</h2>
 <div class="content">目前共有 <em>1 位用户</em>和 <em>46 位游客</em>在线。<div class="item-list"><h3>在线用户</h3><ul><li>simontao</li></ul></div></div>
</div>
</td>
   <td id="main">
<div class="breadcrumb"><a href="/main/">主页</a></div><h2>Linux  Shell简介</h2>
<!-- begin content -->
<div class="node">
 <div class="content">
<p><b>原文：</b> http://www.mandrakeuser.org/doc<br />
<b>中译本：</b>吴晓光 http://dummy.linux.net.cn/~xgwu/cmuo/<br />
<b>整理：</b> <a href="http://www.linuxsir.org/bbs/member.php?u=6933" target="_blank">flaboy</a> 北南南北<br />
<b>点评：</b>flaboy兄当时整理时发在了LinuxSir.Org 论坛 SHELL讨论区中，<a href="http://www.linuxsir.org/bbs/showthread.php?t=20476" target="_blank">《Linux Shell简介》</a>，是作为基础教材的形式帖出的，他在整理时“本文编译整理时对相关章节做了相应的删改处理，去掉了针对Mandrake Linux的部分内容。”；</p>
<p>我看这个文档极其不错，进行了再次整理，并对文档的结构进行了调整，根据文档的内容，我适当的加了序列号，并做了一个目录，主要是方便大家阅读；感谢原作者及中译者，同时也感谢flaboy兄的整理； </p>
<p><font size=4><b>目录</b></font></p>
<p><a href="?q=node/135#0"><b>版权信息</b></a><br />
<a href="?q=node/135#00"><b>前言</b></a><br />
<a href="?q=node/135#1"><b>第一篇：超级工具／Terminals，xterms 和 Shells</b></a></p>
<ul>
<a href="?q=node/135#1.1">一、超级工具</a><br />
<a href="?q=node/135#1.2">二、为了说明 shell ，这里需要一些背景知识。</a></p>
<ul>
<a href="?q=node/135#1.21">1、Terminals, xterms 与 Shells</a><br />
<a href="?q=node/135#1.22">2、终端（Terminals）</a><br />
<a href="?q=node/135#1.23">3、xterms</a><br />
<a href="?q=node/135#1.24">4、Shells</a>
</ul>
<p><a href="?q=node/135#1.3">三、Shell 起步</a>
</ul>
<p><a href="?q=node/135#2"><b>第二篇：自动补齐／命令行的历史记录／编辑命令行／可用的 Shell 快捷方式</b></a></p>
<ul>
<a href="?q=node/135#2.1">一、自动补齐；</a><br />
<a href="?q=node/135#2.2">二、命令行的历史记录</a><br />
<a href="?q=node/135#2.3">三、可用的 Shell 快捷方式</a>
</ul>
<p><a href="?q=node/135#3"><b>第三篇：命令的排列／命令的任务调度／命令的替换</b></a></p>
<ul>
<a href="?q=node/135#3.1">一、命令的排列</a><br />
<a href="?q=node/135#3.2">二、命令的任务调度</a><br />
<a href="?q=node/135#3.3">三、命令的替换</a>
</ul>
<p><a href="?q=node/135#4"><b>第四篇：文件名匹配／输出重定向</b></a></p>
<ul>
<a href="?q=node/135#4.1">一、文件名匹配</a><br />
<a href="?q=node/135#4.2">二、引用 shell 的特殊字符</a><br />
<a href="?q=node/135#4.3">三、输出重定向</a></p>
<ul>
<a href="?q=node/135#4.31">1、在多个命令间重定向</a><br />
<a href="?q=node/135#4.32">2、重定向至文件</a>
</ul>
</ul>
<p><a href="?q=node/135#5"><b>第五篇：bash 配置文件／提示符／改变 $PATH</b></a></p>
<ul>
<a href="?q=node/135#5.1">一、bash 配置文件</a><br />
<a href="?q=node/135#5.2">二、提示符</a><br />
<a href="?q=node/135#5.3">三、改变 $PATH</a>
</ul>
<p><a href="?q=node/135#6"><b>第六篇：命令的别名、Shell 函数／从这里出发／Shell 常见问题</b></a></p>
<ul>
<a href="?q=node/135#6.1">一、命令的别名、Shell 函数</a></p>
<ul>
<a href="?q=node/135#6.11">1、命令的别名</a><br />
<a href="?q=node/135#6.12">2、Shell 函数</a>
</ul>
<p><a href="?q=node/135#6.2">二、从这里出发</a>
</ul>
<p><a href="?q=node/135#7"><b>关于本文</b></a><br />
<a href="?q=node/135#8"><b>相关文档</b></a></p>
<p><font color=blue><b><br />
+++++++++++++++++++++++++++++++++++++++++++++++++++++<br />
正文<br />
+++++++++++++++++++++++++++++++++++++++++++++++++++++<br />
</b></font></p>
<p><font size=4 id="0"><b>版权信息</b></font></p>
<p>本文的内容来源于 MUO 的 Basics 部分，其原始英文版可以从这里获得<a href="http://www.mandrakeuser.org/docs/">http://www.mandrakeuser.org/docs</a>。中文版来自吴晓光的CMUO <a href="http://dummy.linux.net.cn/~xgwu/cmuo/">http://dummy.linux.net.cn/~xgwu/cmuo/</a>。MUO 是 Mandrake Linux（ http://www.mandrakelinux.com/ ）为用户提供的入门手册，其内容实用并且实时更新，非常适合初学者做入门参考。与常见的各种Linux教程不同，MUO介绍给Linux初学者的是学习Linux的方法而非对某个系统的描述，这对各种有着千差万别的Linux发行版的学习尤为重要。</p>
<p>本文编译整理时对相关章节做了相应的删改处理，去掉了针对Mandrake Linux的部分内容。</p>
<p><font size=4 id="00"><b>前言</b></font><br />
使用 Shell</p>
<p>以下将介绍并解释基本的 shell 命令和机制。</p>
<p><font size=4 id="1"><b>第一篇：超级工具／Terminals，xterms 和 Shells</b></font></p>
<p><font size=4 id="1.1"><b><br />
一、超级工具<br />
</b></font></p>
<p>您或许听过这样的论调：命令行(the mommand line)早就已经过时了，那东西神秘兮兮的，等等。有些人甚至觉得操作系统中应该没有这些命令才好。</p>
<p>事实是上，您可以不懂任何 shell ，就能使用 Linux 。您启动系统后可以直接进入 X Window ，最后在 X Window 下关机。<br />
我坚信，用 Linux 而不懂 shell ，就象开车只会用头档(first gear)一样。当然，最初看起来，直接而简单，在大多数情况下都管用。但速度慢，而且无法真正体验驾驶的乐趣。</p>
<p>对，命令行很有趣。就象用一大堆收集到的积木，竟可以完成许多意想不到的创举，一些极其复杂的工作，只需几行命令就可以解决。这是因为，在 Unix 中，shell 可不是简单的命令解释器（典型的有 Windows 中的 DOS ），而是一个全功能的编程环境。<br />
这并不意味着 shell 非常容易学通，您知道，好事多磨，这还是要花点工夫的。;-) 但请相信我，这绝对值得。您在很短时间内，就能被一大帮门外汉吹捧为 Unix wizard（奇才） 。*grin*<br />
<font size=4 id="1.2"><b><br />
二、为了说明 shell ，这里需要一些背景知识。<br />
</b></font><br />
<font size=3 id="1.21"><b><br />
1、Terminals, xterms 与 Shells<br />
</b></font></p>
<p>追溯到 Unix 诞生的那个年代，当时还没有现在流行的"个人计算机"。被称为计算机的机器，还是吞吐磁带与 magnetic memory （用术语'core'来表示系统 memory）的庞然大物。DEC 公司（现在的 Compaq）推出的 PDP-11 ，体积小（被称为 mini）而且价格底，在大学中引起了巨大的反响，很多学校直到那时才买得起一台计算机（PDP-11 物美价廉，只有 10000$）。</p>
<p>这些机器的操作系统由汇编语言、机器语言写成，所以运行起来效率很高，但都无法移植(unportable)。每家计算机公司都给自己的机器配上独有的操作系统，然后再销售。</p>
<p>这种笨拙的作法很快就被人们意识到了，于是就开始兴建一个可以在不同品牌机器上运行的操作系统。1969 年，Ken Thompson 开始写后来成为 Unix 的第一行代码。（Thompson 曾经参加了一个项目：MULTICS，Unix 是与这有关的一个玩笑词） 其实，Dennis Ritchie 为这个新的操作系统设计了一种新的编程语言-- C 语言后，事情才真正开始。</p>
<p>虽然 Unix 的效率不及原来的操作系统，但有三个突出的优点：可以任意移植到其他机器，其中的 C 语言大大简化了编程，而且这些都 free 。很快，全美国的大学都忙着开始为机器安装 Unix 。<br />
<font size=3 id="1.22"><b><br />
2、终端（Terminals）<br />
</b></font></p>
<p>Unix 是可以在许多种机器上运行的操作系统，但人们又如何使用这些机器呢？他们是通过哑终端来连接到这些机器，也就是用键盘、显示器及足够的 electronics （电子元件）组成的机器与中央计算机(central computer)相连。在这些终端上，用户可以敲字符（teletypy），这就是字符串'tty'表示终端设备文件，和'getty'命令的名称来历。</p>
<p>您可能会问，现在这些东西都在哪儿。 这些终端的厂家无法达成一项最终标准，这导致每种牌子的终端都有各自的键盘布局、各自的在屏幕上显示字符的方法、发送或接收什么信号表示什么字符、控制代码等等。</p>
<p>为了避免这些混乱，就创建了一个含有所有不同终端特性的(capability)文件，这就是'termcap'。用一个工具打开'/etc/termcap'瞧瞧，可别吓着了 ;-) 。</p>
<p>Linux 终端大多数用'vt100'或'linux'作为终端类型。<br />
<font size=3 id="1.23"><b><br />
3、xterms<br />
</b></font></p>
<p>在八十年代初期，产生了一个 Unix 的图形子系统-- the X Window System 。九十年代早期，为了更好地实现基于 Intel 的 Unix 类系统上（如FreeBSD、NetBSD、Linux）的应用，产生了一个系统分支-- XFree86 。</p>
<p>X Window 中一个很大的好处是可以运行多个虚拟(virtual)终端。甚至在 X Window 下就有这么个应用程序--'xterm'。您将发现'xterm'和'virtual terminal'在很多情况下都是一样的。有的地方说'打开一个 xterm'，其实您不是非要用'xterm'程序，其他的终端模拟器(terminal emulator)，如 rxvt、konsole、aterm、eterm、wterm 等等，一样有效。</p>
<p>终端模拟器（又称为虚拟终端）通过伪(pseudo) tty 设备-- pty 与系统相连，并且使用自己的显示标准-- xterm 。这导致不同的终端模拟器可能在一些按键或程序上存在细小的差别，这取决于模拟器多大程度上遵守了'xterm'的显示标准。<br />
<font size=3 id="1.24"><b><br />
4、Shells<br />
</b></font></p>
<p>为了在终端中运行程序，需要 shell 。shell 是操作系统的一部分，用来与用户打交道，并且可以用来协调各个命令。</p>
<p>第一个真正的 Unix shell -- 'sh'，亦称为'Bourne shell'，诞生于 1975 年，作者是 Steve Bourne 。很快，出现了其他 shell ，如基于原始'Bourne shell'的'ksh'、'zsh'，后者常用作专属 Unixes 系统中的标准 shell ；也有一些从 C 语言中衍生出来的 shell ，如'csh'或'tcsh'。</p>
<p>在 Linux 中，标注的 shell 是'bash'，即 the GNU Bourne-Again Shell （有点玩笑的味道……）。这个 shell 功能非常强大（甚至有人觉得太庞大了），压缩的 man page 就有 50 KB 。<br />
<font size=4 id="1.3"><b><br />
三、Shell 起步<br />
</b></font></p>
<p>首先，有一点小说明：在平常应用中，建议您不要用'root'帐号运行 shell ，如果您还是新手，这一点尤其要注意。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是'root'，那就不同了，只要敲几个字母，就可能导致灾难性后果。</p>
<p>当您登入系统或打开一个 xterm 窗口，首先看到的是提示符(prompt)。Red Hat Linux 的标准提示符包括了您的用户名、登入的主机名（没有设置的话，是'localhost'）、当前所在的目录(working directory)、提示符号：<br />
<div class="codeblock"><code>[tom@belbo tom]$</code></div><br />
我以用户名'tom'登入名为'belbo'的主机，当前在我的 home 目录--'/home/tom'中。'root'的提示符：<br />
<div class="codeblock"><code>[root@belbo root]#</code></div><br />
除了不同的用户名外，提示符号由'$'变成了'#'。根据 Bourne shell 的传统，普通用户的提示符以'$'结尾，而超级用户用'#'。</p>
<p>提示符的每个部分都可以定制，您在后面将有更深的了解。</p>
<p>要运行命令的话，您只要在提示符后敲进命令，然后在按 <ENTER> 键。shell 将在其路径中（详情见后）搜索这个命令，找到以后就运行，并在终端里输出相应的结果（如果有的话），命令结束后，再给出新的提示符：<br />
<div class="codeblock"><code>[tom@belbo tom]$ whoami<br />tom<br />[tom@belbo tom]$</code></div></p>
<p>顺带指出，当您敲 ENTER 时，光标(cursor)在哪里并不要紧，因为 shell 总是会整行地读取。</p>
<p>基本的命令有：'ls'（list directory ，列出目录内容）、'cp'（copy ，复制）、'mv'（move / rename ，移动／重命名），'cd '（change directory ，改变目录），这些命令后面都可以跟上一帮可选项，这方面 man page 有详细的介绍（man ls, man mv 等等）。<br />
在您动身前往 shell 领地前，这里有几个术语(terminology)的简短说明。命令可能带一些可选项（options）、参数（arguments）：<br />
<div class="codeblock"><code>mv -i file dir</code></div></p>
<p>其中'-i'是命令'mv'的一个可选项，而'file'和'dir'则是参数。所有可选项在该命令的 man page 都中有详细的介绍（此例中用 man mv），而参数则由您提供。可选项决定命令如何工作，而参数则用于确定命令作用的目标。</p>
<p>到目前为止，介绍得有点象许多人厌恶轻视的 DOS shell ，但伴随着下面的介绍，您将会有新的体验。</p>
<p><font size=4 id="2"><b><br />
第二篇：自动补齐／命令行的历史记录／编辑命令行／可用的 Shell 快捷方式</b></font></p>
<p>Unix （及后继者 Linux）在命令行下面诞生，因此，Unix 中的命令行有许多非常实用的功能。在本篇中，我们将来作一些了解。<br />
<font size=4 id="2.1"><B><br />
一、自动补齐；<br />
</b></font></p>
<p>如何用'cd'（改变目录，change directory）最快地从您当前所在的 home 目录跳到'/usr/src/redhat/'呢？<br />
<div class="codeblock"><code>cd /u&lt;TAB&gt;sr&lt;TAB&gt;r&lt;TAB&gt;</code></div><br />
这称为'命令行自动补齐'(automatic command line completion)，这在平常应用中是不可缺少的。让我们仔细看看这个例子：<br />
<div class="codeblock"><code>cd /u&lt;TAB&gt;</code></div><br />
扩展成了 cd /usr/ ，很简单吧。下面的<br />
<div class="codeblock"><code>cd /u&lt;TAB&gt;sr&lt;TAB&gt;</code></div></p>
<p>扩展为 cd /usr/src/ 。如果您只敲了cd /u<TAB>s<TAB>，'/usr'下匹配的（'cd /u*/s*'）三个子目录将列出供您选择：'/usr/sbin'、'/usr/share'和'/usr/src'。</p>
<p>因此，<TAB> 键可以很方便地用于根据前几个字母，来查找匹配的文件或子目录。比如，ls /usr/bin/zip<TAB> 将列出所有'/usr/bin'下面，以字符串'zip'开头的文件或子目录。当然，完成这类任务还有更厉害的命令，但这个方法确实很管用。</p>
<p>另外，碰到长文件名时就显得特别方便。假设您要安装一个名为'boomshakalakwhizbang-4.6.4.5-i586.rpm'的 RPM 包，您输入 rpm -i boom<TAB> ，如果目录下没有其他文件能够匹配，那 shell 就会自动帮忙补齐。<br />
<Code><br />
cd /u<TAB>sr<TAB>l<TAB><br />
</code></p>
<p>将扩展成 cd /usr/src/linux ，并等待继续。'/usr/src'中有两个匹配的目录：'/usr/src/linux-[...]'、'/usr/src/linux'。如何告诉 shell 您想要后面的那个呢？只要跟一个斜线（/ ，slash），就可以选择后面的那个了。</p>
<p>假如您不确定是'/usr/src/linux/Documentation'还是'/usr/src/linux/documentation'。而您知道，Linux 是区分大小写的。如果已经仔细读过前面部分的话，您想到可以用：<br />
<Code><br />
cd /u<TAB>sr<TAB>l<TAB>/d<TAB><br />
</code></p>
<p>扩展成了'/usr/src/linux/drivers/'，因此应该是'Documentation'(大写的'D')。</p>
<p>这种补齐对命令也有效：<br />
<div class="codeblock"><code>[tom@belbo tom]$ gre&lt;TAB&gt;<br /><br />grecord grefer grep<br /><br />[tom@belbo tom]$ gre</code></div><br />
在这里 shell 将列出所有以字符串'gre'开头的已知命令。<br />
<font size=4 id="2.2"><B><br />
二、命令行的历史记录<br />
</b></font></p>
<p>通过按向上方向键，您可以向后遍历近来在该控制台下输入的命令。用向下方向键可以向前遍历。与 SHIFT 键连用的话，您还可以遍历以往在该控制台中的输出。您也可以编辑旧的命令，然后再运行。</p>
<p>按 <CTRL r> 后，shell 就进入"reverse-i(ncremental)-search"（向后增量搜索）模式。现在输入您要找的命令的首字母：</p>
<p>(reverse-i-search)`':. 敲入 'i'可能会变成：</p>
<p>(reverse-i-search)`i': isdnctrl hangup ippp0</p>
<p>如果您再按 <ENTER> 键，上面的命令将再次执行。而如果您按了向右、向左方向键或 <ESC> ，上面的命令将回到普通的命令行，这样您就可以进行适当编辑。</p>
<p>编辑命令行</p>
<p>通过光标和功能键（Home、End 等键），您可以浏览并编辑命令行，如果您需要，还可以用键盘的快捷方式来完成一般的编辑：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL k&gt;：删除从光标到行尾的部分<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL u&gt;：删除从光标到行首的部分<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ALT d&gt;：删除从光标到当前单词结尾的部分<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL w&gt;：删除从光标到当前单词开头的部分<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL a&gt;：将光标移到行首<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL e&gt;：将光标移到行尾<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ALT a&gt;：将光标移到当前单词头部<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ALT e&gt;：将光标移到当前单词尾部<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CTRL y&gt;：插入最近删除的单词<br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;!$&gt;：重复前一个命令最后的参数。</code></div></p>
<p>例如：您用命令 mkdir peter/pan/documents/tinkerbell 新建了一个目录，现在您向用命令'cd'进入该目录，您可以用 cd !$，shell 将把前一个命令'mkdir'的参数添加到现在的'cd'后面。</p>
<p>当您更深入了解Linux后，将看到这些快捷方式在其他应用程序下输入时，有时也有效，比如，在浏览器中的输入框中。<br />
<font size=4 id="2.3"><B><br />
三、可用的 Shell 快捷方式<br />
</b></font></p>
<p>Red Hat Linux 带有不少快捷方式，其中一部分是 bash 原来就有的，而还有一些则是为您预先设置的（在后面您将看到如何设置）。</p>
<p>由于 home 目录是每位用户的活动中心，许多 Unix 对此有特殊的快捷方式。</p>
<p>'~'就是您的 home 目录的简写形式。我们假设您在其他目录，想把一个名为'sometext'的文件复制到您 home 目录下的 'docs'子目录中。除了输入：<br />
<div class="codeblock"><code>cp sometext /home/myusername/docs</code></div><br />
您还可以用简写：<br />
<div class="codeblock"><code>cp sometext ~/docs</code></div></p>
<p>理论上，这也可以应用在命令'cd'上。无论当前路径在哪里，cd ~ 将回到您的 home 目录。其实还可以简化，只要键入 cd ，就可以返回 home 目录了。</p>
<p>Red Hat Linux 为您提供了一些预先设置的快捷方式（称为'别名'，aliases），比如：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ll ：将执行&#039;ls -l -k&#039;（以长格式列出目录内容，包括一些文件属性，并以 KB 而不是 byte 为单位显示文件大小）<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls ：将执行&#039;ls -F --color=auto&#039;（列出目录内容，加上文件类型标识，并使用颜色）</code></div><br />
现在，您应该对 shell 及一些快捷方式有了进一步的了解，下面我们来看看除了应用一些简单的命令，shell 还能作什么。</p>
<p><font size=4 id="3"><B>第三篇：命令的排列／命令的任务调度／命令的替换</b></font></p>
<p><font size=4 id="3.1"><b><br />
一、命令的排列<br />
</b></font></p>
<p>现在您将看到一些常用的命令排列。您可能想在一行中给出所有命令，然后就可以把注意力转移到其他地方。没问题，shell 允许您在不同的命令之间，放上特殊的排列字符(queuing characters) 。这儿将介绍最常用的两种。</p>
<p>请注意，为了看起来更清楚，我在这些字符两旁加了空格。而在实际应用中，您不一定要这么做，'ls -a ; du -hs'和'ls -a;du -hs'的效果是一样的。</p>
<p><div class="codeblock"><code>command1 ; command2</code></div></p>
<p>先执行 command1 ，不管 command1 是否出错，接下来执行 command2 。</p>
<p>例如：<br />
<div class="codeblock"><code>ls -a ; du -hs</code></div><br />
将先在屏幕上列出目录中的所有内容，然后列出所有目录及其子目录所占磁盘大小。<br />
<div class="codeblock"><code>command1 &amp;&amp; command2</code></div><br />
只有当 command1 正确运行完毕后，才执行 command2 。</p>
<p><b>例如：</b><br />
<div class="codeblock"><code>ls -a bogusdir &amp;&amp; du -hs</code></div></p>
<p>将返回 ls: bogusdir: No such file or directory ，而'du'则根本没有运行（这是因为您没有'bogusdir'目录）。如果您将符号换成了';'，'du'将被执行。</p>
<p>为了进一步说明';'和'&amp;&'的区别，及一般命令排列的用处，下面举一个经典的例子：Linux 内核的编译和安装。</p>
<p>要编译、安装 Linux ，您需要执行一串命令：'make dep'、'make clean'、'make bzImage'、'make modules'、'make modules_install'和'make install'。如果要等一个命令完成后，再输入下一个，再等，再输入，……，那就太麻烦了。另一方面，每个命令只有当前面的命令都正确执行完毕后，才能开始执行。如果您用';'来排列命令，则即使有命令执行失败，后面的也照常运行，最后，您可能在'/boot'目录下得到一个有问题的内核映像(image)。而用'&amp;&'：<br />
<div class="codeblock"><code>make dep &amp;&amp; make clean &amp;&amp; make bzImage &amp;&amp; make modules &amp;&amp; make modules_install &amp;&amp; make install</code></div></p>
<p>不需要中途打断，就可以编译内核及其模块，并完成后面的安装。<br />
<font size=4 id="3.2"><b><br />
二、命令的任务调度<br />
</b></font></p>
<p>当您在终端里运行一个命令或开启一个程序时，终端要等到命令或程序运行完毕后，才能再被使用。在 Unix 中，我们称这样的命令或程序在前台(foreground)运行。如果您想在终端下运行另一个命令，则需要再打开一个新的终端。</p>
<p>但这里还有一个更优雅的办法，称为任务调度(jobbing)或后台(backgrounding)。当您运用任务的调度或将命令置于后台，终端就立即解放了，这样一来，终端立即就可以接受新的输入。为实现这样的目的，您只需在命令后面添加一个 &amp; ：<br />
<div class="codeblock"><code>gqview &amp;</code></div></p>
<p>告诉 shell 将图片查看器'GQview'放到后台去执行（即当成 job 来运行）。</p>
<p>命令 jobs 将告诉您，在这个终端窗口中，运行着哪些命令与程序：<br />
<div class="codeblock"><code>jobs<br /><br />[1]+ Running gqview &amp;</code></div></p>
<p>当您要关闭终端窗口时，这一点就很重要，因为关闭终端将导致所有在其中运行的任务都将被中止，在此例中，如果您关闭了终端，由这个终端开启的 GQview 程序也将被关闭。</p>
<p>但如何将前台运行的一个程序放到后台去？没问题：<br />
<div class="codeblock"><code>gqview<br /><br />&lt;CTRL z&gt;<br /><br />[2]+ Stopped gqview<br /><br />bg<br /><br />[2]+ gqview &amp;</code></div></p>
<p>组合键 <CTRL z> 将挂起终端中正在运行的程序，然后您就可以用 bg 命令将其放到后台去执行。</p>
<p>请注意，在后台运行图形应用程序有时候是有用处的，这样可以在终端下显示这个程序的出错信息，虽然这对您可能没有直接的帮助，当如果碰到了麻烦，向别人询问时，这些出错提示就有用武之地了。</p>
<p>一些图形程序，很可能还处在测试期(Beta)，尽管在后台执行，也会在终端中输出一些信息。如果您对此不满，可以用下面命令：<br />
<div class="codeblock"><code>command &amp;&gt;/dev/null &amp;</code></div><br />
这不仅将程序送到后台执行，还将其输出发到'/dev/null'文件。'/dev/null'是系统的"碎纸机" (shredder)，所有送到那里的信息都将消失殆尽。<br />
<font size=4 id="3.3"><b><br />
三、命令的替换<br />
</b></font></p>
<p>命令替换(Command substitution)是一项很实用的功能。我们假设，您想看看 XFree86 文档中的 'README.mouse'文件，但您不知道这个文件的位置。但您是位机灵的用户，已经听说了'locate'命令，也安装了'slocate'包，您就可以用：<br />
<div class="codeblock"><code>locate README.mouse</code></div><br />
发现那个文件在'/usr/X11R6/lib/X11/doc'。现在您就可以在终端里用'less'或在文件管理器中进入那个目录然后读取文件。而命令替换可以给您带来一些便捷：<br />
<div class="codeblock"><code>less $(locate README.mouse)</code></div></p>
<p>一步到位。命令'locate README.mouse'的输出(= /usr/X11R6/lib/X11/doc/README.mouse)作为'less'的参数，然后就可以显示文件内容了。</p>
<p>这种机制的语法是：<br />
<div class="codeblock"><code>command1 $(command2)</code></div></p>
<p>除了'$( )'，您还可以用后引号(backquote)：<br />
<div class="codeblock"><code>command1 `command2`</code></div></p>
<p>这样虽然可以减少输入，但可读性差，而且很容易就和没有替换功能的一般单引号混淆。我更欣赏前一种方法，但这最终起决于您。</p>
<p>这里有另外一个例子。我们假设，您打算结束一个名为'rob'的程序。您先得用命令'pidof'找出相应的进程号(Process ID)，然后以这个 PID 为参数，运行'kill'命令，这样就可以结束'rob'程序。除了用：<br />
<div class="codeblock"><code>pidof rob<br /><br />567<br /><br />kill 567</code></div></p>
<p>您还可以试试：<br />
<div class="codeblock"><code>kill `pidof rob`</code></div></p>
<p>怎么样，效率有所提高吧？</p>
<p>在下一篇中，我将接着介绍 shell 的另外两种实用的机制：文件名匹配、输出重定向。</p>
<p><font size=4 id="4"><b>第四篇：文件名匹配／输出重定向</b></font></p>
<p><font size=4 id="4.1"><b><br />
一、文件名匹配<br />
</b></font></p>
<p>文件名匹配使得您不必一一写出名称，就可以指定多个文件。您将用到一些特殊的字符，称为通配符(wildcards)。</p>
<p>假设您想用'rm'命令删除目录下所有以字符串'.bak'结尾的文件。除了在'rm'后跟上所有文件名作为参数，您还可以用通配符'*'：<br />
<div class="codeblock"><code>rm *.bak</code></div></p>
<p>'*'可匹配一个或多个字符。在本例中，您告诉 shell 将命令'rm'的参数扩展到"所有以'*.bak'结尾的文件"，shell 就将扩展后的参数告诉'rm'命令。</p>
<p>您将看到，shell 在命令执行前，就将读取并解释命令行。正是因为这个，您才可以将通配符用于 shell 命令的参数中。</p>
<p>让我们更进一步地来认识通配符'*'。假定您有个目录，其中含文件'124.bak'、'346.bak'及'583.bak'。您想只保留文件'583.bak'，可以用：<br />
<div class="codeblock"><code>rm *4*.bak</code></div></p>
<p>shell 就将'*4*.bak'扩展成"所有含'4'并以'.bak'结尾的字符串"。</p>
<p>注意到 rm 4*.bak 无法工作，因为这匹配的是以'4'开头的文件。由于目录中没有这样的文件，shell 将这个模式扩展为空的字符串，故'rm'将返回出错信息：<br />
<div class="codeblock"><code>rm: cannot remove `4*.bak&#039;: No such file or directory</code></div></p>
<p>如果您想保留文件'345.bak'，而删除'124.bak'和'583.bak'。这看起来有些难度，因为被删文件的名称除了后缀其他都不同。但幸运的是，您可以用不含有来指定文件：<br />
<div class="codeblock"><code>rm *[!6].bak</code></div></p>
<p>这将被读为：除了以'6.bak'结尾的文件，删除其他所有以'.bak'结尾的文件。您必须将取反号(negation sign)与取反字符（这里是 6）放到括号中，不然的话，shell 会将惊叹号(exclamation mark)解释成历史记录替换的开始(the beginning of a history substitution)。取反号在本篇介绍的所有匹配模式中都有效。</p>
<p><b>请注意：</b>通配符'*'与取反号连用，很容易产生问题。猜猜<br />
<div class="codeblock"><code>rm *[!6]*.bak</code></div><br />
表示什么？这个命令将删除所有文件，甚至包括名称中包含'6'的文件。如果您将通配符'*'放到了取反号前面和后面，实际上取反号将失效，因为 shell 将其解释为"所有名称中任何位置都不含该字符的文件"。在我们的例子里，只有文件'666.bak'不符合该模式。</p>
<p>第二个通配符是问号(question mark)：'?'。在匹配时，一个问号只能代表一个字符。为了示范其用途，我们在上例的假设中添加两个新文件：'311.bak~'和'some.text'。现在，列出所有在点号后有四个字符的文件：<br />
<div class="codeblock"><code>ls *.????</code></div></p>
<p>问号通配符能够有效地避免上面提到的'取反号陷阱'(negation trap)：<br />
<div class="codeblock"><code>rm *[!4]?.*</code></div></p>
<p>将扩展成"所有除了点号前倒数第二个字符为'4'的文件"，也就是只保留文件'346.bak'。</p>
<p>您可能会问，有没有其他匹配方式？到目前为止，您只看到了在指定位置匹配唯一字符的方法。但其实您也可以这样：<br />
<div class="codeblock"><code>ls [13]*</code></div></p>
<p>将列出所有以字符'1'或'3'开头的文件；在我们的例子中，文件'124.bak'、'311.bak~'和'346.bak'匹配。注意到您必须用中括号将匹配的模式括起来，否则模式只匹配以字符串'13'开头的文件。</p>
<p>接下来，您将高兴地看到还可以定义匹配的范围：<br />
<div class="codeblock"><code>ls *[3-8]?.*</code></div></p>
<p>将列出所有点号前倒数第二个字符落在'3'到'8'范围的文件。在我们的例子中，匹配的文件是'346.bak'和'583.bak'。<br />
<font size=4 id="4.2"><b><br />
二、引用 shell 的特殊字符<br />
</b></font></p>
<p>但是，上面的那些机制存在一个缺点：shell 总在命令执行前，试着进行扩展。有时候，会变得很棘手：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文件名包含特殊字符。假设您在那个目录中还有一个名为&#039;!56.bak&#039;的文件。下面试图进行模式匹配：<br />rm !*<br />rm<br />rm: too few arguments</code></div></p>
<p>shell 将'!*'解释成历史记录的替换（加入前一个命令的所有参数），而不是匹配方式。</p>
<p>l         命令本身带特殊字符作参数。一些 Linux 下的命令行工具，比如 (e)grep、sed、awk、find 及 locate ，都使用自己的正则表达式(regular expressions)。这些表达式与模式匹配看起来惊人地相似，但在某些地方又有所不同。</p>
<p>但为了使这些特殊命令生效，shell 就不能先将其当作模式匹配来解释：<br />
<div class="codeblock"><code>find . -name [1-9]* -print<br />find: paths must precede expression</code></div><br />
应该是：<br />
<div class="codeblock"><code>find . -name &#039;[1-9]*&#039; -print<br />./346.bak<br />./124.bak<br />./583.bak<br /><br />./311.bak~</code></div></p>
<p>您可以通过反斜线(back slash)来引用特殊字符，比如 ! 、$ 、? 或空格：<br />
<div class="codeblock"><code>ls \!*<br /><br />!56.bak</code></div></p>
<p>或者用（单）引号：<br />
<div class="codeblock"><code>ls &#039;!&#039;*<br /><br />!56.bak</code></div></p>
<p>请注意，要看清楚引号应该放在什么位置。命令 ls '!*' 将查找名为'!*'的文件，这是由于通配符也在引号间，所以只能依照字面来解释。<br />
<font size=4 id="4.3"><b><br />
三、输出重定向<br />
</b></font></p>
<p>Unix 的理念是汇集许多小程序，每个东东都有特殊的专长。复杂的任务不是由大型软件完成，而是运用 shell 的机制，组合许多小程序共同完成。重定向就在其中发挥着重要的作用。<br />
<font size=3 id="4.31"><b><br />
1、在多个命令间重定向<br />
</b></font></p>
<p>这要通过管道(pipe)，由管道符号｜来标识。语法是：<br />
<div class="codeblock"><code>command1 | command2 | command3 等等</code></div></p>
<p>这种格式您一定已经见到过了。管道经常将一个程序的输出送到'more'或'less'来阅读。<br />
<div class="codeblock"><code>ls -l | less</code></div></p>
<p>其中，第一个命令提供目录内容，第二个则将其以翻页的方式显示。更复杂的例子如：<br />
<div class="codeblock"><code>rpm -qa | grep ^x | less</code></div></p>
<p>第一个命令给出所有已安装的 RPM 包，第二个则将其过滤(filter：'grep')，只剩下以'^x'开头的包，第三个命令则将结果以翻页的方式显示。</p>
<p><font size=3 id="4.32"><b><br />
2、重定向至文件<br />
</b></font></p>
<p>有时，您希望将命令的输出结果保存到文件中，或以文件内容作为命令的参数。这可以通过'>'和'<'来实现。<br />
<div class="codeblock"><code>command &gt; file</code></div></p>
<p>将 command 的输出保存到 file 中，这将覆盖 file 中的内容：<br />
<div class="codeblock"><code>ls &gt; dirlist</code></div></p>
<p>将当前目录的内容保存到'dirlist'文件。<br />
<div class="codeblock"><code>command &lt; file</code></div></p>
<p>将 file 内容作为 command 的输入：<br />
<div class="codeblock"><code>sort &lt; dirlist &gt; sdirlist</code></div></p>
<p>将文件'dirlist'的内容送到命令'sort'，然后再将排序后的结果送到文件'sdirlist'。当然，您也可以一步到位：<br />
<div class="codeblock"><code>ls | sort &gt; sdirlist</code></div></p>
<p>一种特殊的方式是'command 2> file'。这将 command 执行的出错信息送到 file 中。这个您到时候会需要……</p>
<p>另一种操作符是'>>'，这将输出添加到已存在的文件中：<br />
<div class="codeblock"><code>echo &quot;string&quot; &gt;&gt; file</code></div></p>
<p>将 string 加到文件 file 中。这是不打开文件而完成编辑的好办法！</p>
<p>但是，'<'和'>'操作符都有一个重要的限制：<br />
<div class="codeblock"><code>command &lt; file1 &gt; file1</code></div></p>
<p>将删除 file1 的内容，而<br />
<div class="codeblock"><code>command &lt; file1 &gt;&gt; file1</code></div></p>
<p>却可以很好地工作，将加工过的 file1 内容加回到文件中。</p>
<p>是不是有点多？;-) 不必惊慌，您完全可以按照自己的速度，一步步地来学习。别忘了，实践是最好的学习方法……</p>
<p>熟知了许多 shell 的机制后， 您可能急着想知道如何来定制环境。在后面的两篇中，您将得到这方面的启示。在最后一篇中，还有一段如何处理 shell 出错信息的常见问答(FAQ)，及一些配置技巧。</p>
<p><font size=4 id="5"><b>第五篇：bash 配置文件／提示符／改变 $PATH</b></font></p>
<p><font size=5 id="5.1"><b><br />
一、bash 配置文件<br />
</b></font></p>
<p>在您的 home 目录下，运行<br />
<div class="codeblock"><code>ls .bash*</code></div><br />
您将看到这些文件：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bash_history ：记录了您以前输入的命令，<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bash_logout ：当您退出 shell 时，要执行的命令，<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bash_profile ：当您登入 shell 时，要执行的命令，<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bashrc ：每次打开新的 shell 时，要执行的命令。</code></div></p>
<p>请注意后两个的区别：'.bash_profile'只在会话开始时被读取一次，而'.bashrc'则每次打开新的终端（如新的 xterm 窗口）时，都要被读取。按照传统，您得将定义的变量，如 PATH ，放到'.bash_profile'中，而象 aliases（别名）和函数之类，则放在'.bashrc'。但由于'.bash_profile'经常被设置成先读取'.bashrc'的内容，您如果图省事的话，就把所有配置都放进'.bashrc'。</p>
<p>这些文件是每一位用户的设置。系统级的设置存储在'/etc/profile'、'/etc/bashrc'及目录'/etc/profile.d'下的文件中。但您得习惯用各自的配置文件：编辑不需要'root'权限，还可以使您的设置更有个性。当系统级与用户级的设置发生冲突时，将采用用户的设置。</p>
<p>读取'.bashrc'的内容，您如果要省点事的话，就把您所有的配置都放进'.bashrc'。</p>
<p>上面的这些文件是每位用户的设置，系统级的设置存储在'/etc/profile'、'/etc/bashrc'及目录'/etc/profile.d'下的文件中。您最好习惯使用各自的配置文件：编辑不需要'root'权限，还可以使您的设置更具个性。当系统级与用户级的设置发生冲突时，将优先采用用户的设置。<br />
<font size=4 id="5.2"><b><br />
二、提示符<br />
</b></font></p>
<p>每次当您打开一个控制台(console)或 xterm 时，最先看到的就是提示符(prompt)，类似于：<br />
<div class="codeblock"><code>account@hostname ~ $</code></div></p>
<p>在默认设置下，提示符将显示您的用户名、主机名（默认是'localhost'）、当前所在目录（在 Unix 中，'~'表示您的 home 目录）。</p>
<p>按照传统，最后一个字符可以标识您是普通用户（$），还是'root'（#）。</p>
<p>您可以通过 $PS1 变量来设置提示符。命令<br />
<div class="codeblock"><code>echo $PS1</code></div></p>
<p>将显示当前的设定。其中可用字符的含义在 man bash 的'PROMPTING'部分有说明。</p>
<p>如何才能完成理想的设置呢？对于健忘的初学者来讲，默认设定有些不友好，因为提示符只显示当前目录的最后一部分。如果您看到象这样的提示符<br />
<div class="codeblock"><code>tom@localhost bin $</code></div></p>
<p>您的当前目录可能是'/bin'、'/usr/bin'、'/usr/local/bin'及'/usr/X11R6/bin'。当然，您可以用</p>
<p>pwd （输出当前目录，print working directory）</p>
<p>能不能叫 shell 自动告诉您当前目录呢？</p>
<p>当然可以。这里我将提到的设定，包括提示符，大都包含在文件'/etc/bashrc'中。您可以通过编辑各自 home 目录下的'.bash_profile'和'.bashrc'来改变设置。</p>
<p>在 man bash 中的'PROMPTING'部分，对这些参数(parameter)有详细说明。您可以加入一些小玩意，如不同格式的当前时间，命令的历史记录号，甚至不同的颜色。</p>
<p>在'~/.bashrc'中，我喜欢的设定是：<br />
<div class="codeblock"><code>PS1=&quot;\[\033[1m\][\w]\[\033[0m\] &quot;</code></div><br />
'root'在'~/.bashrc'中的设定 是：<br />
<div class="codeblock"><code>PS1=&quot;\[\033[0;31m\][\w]\[\033[0m\] &quot;</code></div></p>
<p>这样我得到的提示符就是：<br />
<div class="codeblock"><code>[/usr/bin]</code></div></p>
<p>当用'root'时，变成：<br />
<div class="codeblock"><code>[/usr/bin]</code></div><br />
我已经除掉了主机名和用户名，因为我用不着这些。但我首先想一眼就能看出我的身份是普通用户还是'root'。注意到，普通用户的提示符可以是黑底白字，或白底黑字。</p>
<p>要在终端上获得恰当的颜色调配， 您可以编辑下面这个脚本color ，赋予执行权限（chmod +x color），然后再运行。<br />
<div class="codeblock"><code>#!/bin/bash<br /><br />#<br /><br />#&nbsp;&nbsp; This file echoes a bunch of color codes to the<br /><br />#&nbsp;&nbsp; terminal to demonstrate what&#039;s available.&nbsp; Each<br /><br /><br />#&nbsp;&nbsp; line is the color code of one forground color,<br /><br />#&nbsp;&nbsp; out of 17 (default + 16 escapes), followed by a<br /><br />#&nbsp;&nbsp; test use of that color on all nine background<br /><br />#&nbsp;&nbsp; colors (default + 8 escapes).<br /><br />#<br /><br />T=&#039;gYw&#039;&nbsp;&nbsp; # The test text<br /><br />echo -e &quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40m&nbsp;&nbsp;&nbsp;&nbsp; 41m&nbsp;&nbsp;&nbsp;&nbsp; 42m&nbsp;&nbsp;&nbsp;&nbsp; 43m\<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; 44m&nbsp;&nbsp;&nbsp;&nbsp; 45m&nbsp;&nbsp;&nbsp;&nbsp; 46m&nbsp;&nbsp;&nbsp;&nbsp; 47m&quot;;<br /><br />for FGs in &#039;&nbsp;&nbsp;&nbsp; m&#039; &#039;&nbsp;&nbsp; 1m&#039; &#039;&nbsp; 30m&#039; &#039;1;30m&#039; &#039;&nbsp; 31m&#039; &#039;1;31m&#039; &#039;&nbsp; 32m&#039; \<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#039;1;32m&#039; &#039;&nbsp; 33m&#039; &#039;1;33m&#039; &#039;&nbsp; 34m&#039; &#039;1;34m&#039; &#039;&nbsp; 35m&#039; &#039;1;35m&#039; \<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#039;&nbsp; 36m&#039; &#039;1;36m&#039; &#039;&nbsp; 37m&#039; &#039;1;37m&#039;;<br /><br />&nbsp; do FG=${FGs// /}<br /><br />&nbsp; echo -en &quot; $FGs \033[$FG&nbsp; $T&nbsp; &quot;<br /><br />&nbsp; for BG in 40m 41m 42m 43m 44m 45m 46m 47m;<br /><br />&nbsp;&nbsp;&nbsp; do echo -en &quot;$EINS \033[$FG\033[$BG&nbsp; $T&nbsp; \033[0m&quot;;<br /><br />&nbsp; done<br /><br />&nbsp; echo;<br /><br />done<br /><br />echo</code></div></p>
<p>一种更适当的设定：<br />
<div class="codeblock"><code>PS1=&quot;\u: \w\\$ &quot;</code></div><br />
这样，提示符就变成：<br />
<div class="codeblock"><code>user_name: /usr/bin$</code></div></p>
<p>您可以通过命令 export 来测试不同的设置（比如，export PS1="\u: \w\\$ "）。如果找到了适合的提示符，就将设置放到您的'.bashrc''中。这样，每次打开控制台或终端窗口时，都会生效。</p>
<p>您甚至可以给提示符设定主题(theme)，也就是搭配不同的颜色，使其看起来象很棒的 ol<br />
的 C64 提示符。如果您对此感兴趣，可以看一下<br />
Bashish（ http://hem.passagen.se/arnognulf/index2.html ）。<br />
<Font size=4 id=5.3><b><br />
三、改变 $PATH<br />
</b></font></p>
<p>'$PATH'与'$PS1'一样，也是环境变量。输入<br />
<div class="codeblock"><code>set</code></div></p>
<p>将列出所有当前定义的环境变量。</p>
<p>您看到的这些环境变量在 shell 的配置文件中定义，可能是用户自己的配置文件，也可能是由'root'通过'/etc'下面的系统级文件定义的。如果您使用 X ，更多的一些变量将由 X 、您的窗口管理器或桌面环境的启动文件配置。</p>
<p>如果对这些设置不很清楚，您暂时最好不要随便改动。了解如何改变 $PATH 变量很有用，因为这个变量决定了 shell 将到哪些目录中寻找命令或程序。如果要执行的命令的目录在 $PATH 中，您就不必输入这个命令的完整路径，直接输入命令就可以了。一些第三方软件没有将可执行文件放到 Linux 的标准目录中。因此，将这些非标准的安装目录添加到 $PATH 是一种解决的办法。此外，您也将看到如何处理一般的环境变量。</p>
<p>首先，作为惯例，所有环境变量名都是大写。由于 Linux 区分大小写，这点您要留意。当然，您可以自己定义一些变量，如'$path'、'$pAtH'，但 shell 不会理睬这些变量。</p>
<p>第二点是变量名有时候以'$'开头，但有时又不是。当设置一个变量时，您直接用名称，而不需要加'$'：<br />
<div class="codeblock"><code>PATH=/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin</code></div><br />
要获取变量值的话，就要在变量名前加'$'：<br />
<div class="codeblock"><code>echo $PATH<br /><br />/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin</code></div><br />
否则的话，变量名就会被当作普通文本了：<br />
<div class="codeblock"><code>echo PATH<br /><br />PATH</code></div></p>
<p>处理 $PATH 变量要注意的第三点是：您不能只替换变量，而是要将新的字符串添加到原来的值中。在大多数情况下，您不能用'PATH=/some/directory'，因为这将删除 $PATH 中其他的所有目录，这样您在该终端运行程序时，就不得不给出完整路径。所以，只能作添加：<br />
<div class="codeblock"><code>PATH=$PATH:/some/directory</code></div><br />
这样，PATH 被设成当前的值（以 $PATH 来表示）＋新添的目录。</p>
<p>到目前为止，您只为当前终端设置了新的 $PATH 变量。如果您打开一个新的终端，运行 echo $PATH ，将返回旧的 $PATH 值，而看不到您刚才添加的新目录。因为您先前定义的是一个局部环境变量（仅限于当前的终端）。</p>
<p>要定义一个全局变量，使在以后打开的终端中生效，您需要将局部变量输出(export)，可以用'export'命令：</p>
<p><div class="codeblock"><code>export PATH=$PATH:/some/directory</code></div></p>
<p>现在如果您打开一个新的终端，输入 echo $PATH ，也能看到新设置的 $PATH 了。请注意，命令'export'只能改变当前终端及以后运行的终端里的变量。对于已经运行的终端没有作用。</p>
<p>为了将目录永久添加到您的 $PATH ，只要将'export'的那行添加到您的'.bash_profile'文件中。</p>
<p>请不要在'.bashrc'中设置 PATH ，否则会导致 PATH 中目录的意外增长。您每次打开一个新的 shell ，'.bashrc'都会作用。所以如果在该文件中添加目录，您每次打开一个终端，目录又会被添加。这将导致 PATH 变量由于目录复制，不断地增长。</p>
<p><font size=4 id="6"><b>第六篇：命令的别名、Shell 函数／从这里出发／Shell 常见问题</b></font></p>
<p><font size=4 id="6.1"><b><br />
一、命令的别名、Shell 函数<br />
</b></font></p>
<p>记住所有的命令及各自带的可选项，然后每次一一输入，这确实有点枯燥。但幸运的是，您可以为常用命令定义快捷方式。这些快捷方式可以用较简单的命令别名(alias)，或复杂一些的 shell 函数的语法来定义。<br />
<font size=4 id="6.11"><b><br />
1、命令的别名<br />
</b></font></p>
<p>例如，我用下面的命令来上传 MUO 中的文件：<br />
<div class="codeblock"><code>rsync -e ssh -z -t -r -vv --progress /home/tom/web/muo/rsmuo/docs muo:/www/mandrakeuser/docs</code></div></p>
<p>显然，如果每次都要逐一输入，那我早晚会变成木头。因此我在'~/.bashrc'中定义了别名：<br />
<div class="codeblock"><code>alias upmuo=&#039;rsync -e ssh -z -t -r -vv --progress /home/tom/web/muo/rsmuo/docs muo:/www/mandrakeuser/docs&#039;</code></div></p>
<p>现在，我只要输入 upmuo 就可以完成上传任务了。</p>
<p>定义别名的语法是：<br />
<div class="codeblock"><code>alias shortcut=&#039;command&#039;</code></div></p>
<p>命令中有空格的话 ，就需要用引号（如在命令与可选项间就有空格）。请注意，您可以用单引号或双引号，但他们是有区别的。</p>
<p>单引号将剥夺其中的所有字符的特殊含义，而双引号中的'$'（参数替换）和'`'（命令替换）是例外。这意味着，如果您想在别名中应用变量或命令的替换，就得用双引号。看一下上面的例子，我在'.bashrc'中定义了一个称为 MUOHOME 的变量：<br />
<div class="codeblock"><code>export MUOHOME=$HOME/web/muo/rsmuo/docs</code></div></p>
<p>要在上面的别名中用上这个变量，我就必须用双引号：<br />
<div class="codeblock"><code>alias upmuo=&quot;rsync -e ssh -z -t -r -vv --progress $MUOHOME muo:/www/mandrakeuser/docs&quot;</code></div></p>
<p>否则，别名将查找一个名为'$MUOHOME'的目录或文件。</p>
<p>您可以用'alias'在命令行快速地创建别名，或将命令放到各自的'~/.bashrc'，或放到系统级的'/etc/profile.d/alias.sh'中（而在 Mandrake Linux 8 以前的版本里，用的是'/etc/bashrc'）。要删除一个别名，只要输入：unalias alias 。运行 alias 将列出您系统中所有定义的别名。</p>
<p>如果看一下'~/.bashrc'和'/etc/profile.d/alias.sh'，您会发现系统已经定义了一些别名。您可以为同一个命令定义多个别名。当然，您得先确认别名与其他程序名不同，比如象 alias rm='ls -l' 这样的就不能工作。您可以在命令行输入这些快捷方式，测试一下。如果 shell 找不到相同名称的命令，那您就可以将其用作别名了。</p>
<p>以下别名可能有用（不要忘了引号！） ：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alias rpmq=&#039;rpm -qa | grep&#039; ：现在 rpmq string 就将列出所有名称中含有 string 的已安装 RPM 包，<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alias ls=&#039;ls -ho --color | more&#039; ：ls 将以彩色分页方式列出文件，文件大小以 KB为单位，<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alias use=&#039;du --max-depth=1 | sort -n | more&#039; ：use 将子目录按大小排好，并以分页方式列出，</code></div></p>
<p>目录的别名也可以是可移动的介质：alias dlm='/mnt/cdrom/RedHat/RPMS/' 。</p>
<p><b>提示：</b>将有相似功能的别名以相同字母开头，比如将所有目录的别名以'd'作开头，这样有助于记忆。</p>
<p>我相信，您将会用到这些功能。</p>
<p><font size=4 id="6.12"><b><br />
2、Shell 函数<br />
</b></font></p>
<p>写 shell 函数涉及到了 shell 脚本，这超出了我们讨论的范围（也不在我的掌握范围之内 ;-)）。事实上，shell 函数属于 shell 脚本，但可以在同一 shell 下被预加载(preload)和执行（而一般的 shell 脚本至少要打开一个 sub-shell）。</p>
<p>通过 shell 函数，您可以做很多 aliases 无法完成的事情。下面就是一个例子：<br />
<Code><br />
function apros() { apropos $1 | egrep -v '(3|\(n\)'; }<br />
</code></p>
<p>定义了一个新命令，称为'apros'。apros name 将先执行'apropos name'（即在 man page 中搜索命令），然后将得到的输出送到管道（|），接着用'egrep'过滤，排除第'3'和第'n'章节的 man page ，这个命令可能没什么大用处，但可以整理'apropos'命令的输出。</p>
<p>函数允许您在函数内部任何位置，使用运行时的参数。而别名，则只允许在命令行尾放一个参数（比如前面的别名'rpmq'）。</p>
<p>'$1'就是位置参数(positional parameter)，表示函数第一个参数的位置标识符。依此类推，还有'$2'等。<br />
<div class="codeblock"><code>function apros() { apropos $1 | egrep -v &quot;\($2&quot;; }</code></div></p>
<p>如果您这样运行'apros'命令：<br />
<div class="codeblock"><code>apros name man_section_number</code></div></p>
<p>这个命令将搜索标题中含 name 的 man pages ，但排除 man_section_number 部分：<br />
<div class="codeblock"><code>apros menu 3</code></div></p>
<p>将搜索标题含'menu'的 man page ，但排除第三章节（关于编程的）。注意到您得引用（quote） 两次，而且还用到了双引号：<br />
<div class="codeblock"><code>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 您必须引用&#039;egrep&#039;的搜索模式，这样可以不至于被 shell 误解。<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 您必须用双引号，这样第二个参数才能被正确解释。<br /><br />l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 您必须引用圆括号，这样使&#039;egrep&#039;按字面意思对待对待参数。</code></div></p>
<p>是不是有点意思？;-)</p>
<p>shell 函数的处理类似于别名：将其放到您的'.bashrc'文件，这样就能永久生效了。</p>
<p><font size=4 id="6.2"><b><br />
二、从这里出发<br />
</b></font></p>
<p>我们谈到的只是 shell 的一个开头。掌握了shell 脚本，您就可以做很多事情，比如将任务自动化，纠正别人脚本中的错误，按照您的习惯定制 Linux 系统。如果您打算学习某种复杂的编程语言，那 shell 脚本也是一个很好的开端，因为基本概念都是类似的。</p>
<p>BASH Programming - Introduction HOW-TO：</p>
<p>http://www.ibiblio.org/mdw/HOWTO/Bash-Prog-Intro-HOWTO.html </p>
<p>将更深入这些主题，并且将把您带到 shell 编程的世界。然后可以继续阅读我强烈推荐的 Advanced Bash-Scripting Guide（ http://www.ibiblio.org/mdw/LDP/abs/html/index.html  ），作者是：Mendel Cooper 。</p>
<p>如果您偏好纸书，那我推荐 S. Veeraraghavan 的《Teach Yourself Shell Programming》，Sams 出版社。我倒觉得 O'Reilly 公司由 Newham/Rosenblatt 写的《Learning the bash Shell》，不过尔尔，但这可能只有我这么看 ;-) 。</p>
<p>除了这些，就是练习，练习，再练习。阅读其他人写的 shell 脚本，看看他们在做什么，怎么做，为什么那样做。</p>
<p>请不要用'root'测试您的脚本。Have fun 。</p>
<p><font size=4 id="7"><b>关于本文</b></font></p>
<p>flaboy兄当时整理时发在了LinuxSir.Org 论坛 SHELL讨论区中，是作为SHELL 基础教材的形式帖出的，他在整理时“本文编译整理时对相关章节做了相应的删改处理，去掉了针对Mandrake Linux的部分内容。”；</p>
<p>我看这个文档极其不错，进行了再次整理，并对文档的结构进行了调整，根据文档的内容，我适当的加了序列号，并做了一个目录，主要是方便大家阅读；感谢原作者及中译者，同时也感谢flaboy兄的整理；</p>
<p>我想整理文档也是件比较幸福的事情，至少在看文档的时候，我能知道有哪些是比较关健的，也能得到我想要学的东西，所以我会一直整理文档；如果时间允许并有能力的话，我也会写一些。── 北南南北 </p>
<p>整理文档是没任何技术含量的，为什么你会做呢？</p>
<p>虽然没有技术含量，但我想如果能为他人带来一点点方便，我想我所做的还是值得的，相对原创者和中译者来说，我做的又算什么呢？</p>
<p>── 北南南北 </p>
<p><font size=4 id="8"><b><b>相关文档</b></font></p>
<p><a href="?q=node/134">《详解Bash命令行处理》</a></p>
 </div>
<div class="links"><ul class="links inline"><li class="first node_submitted"><span class="node_submitted">由 北南南北 在 2005/12/18 - 20:49 发表</span></li>
<li class="taxonomy_term_1"><a href="/main/taxonomy/term/1" rel="tag" title="Linux 学习研究" class="taxonomy_term_1">Linux</a></li>
<li class="taxonomy_term_52"><a href="/main/taxonomy/term/52" rel="tag" title="命令/SHELL/PERL" class="taxonomy_term_52">命令/SHELL/PERL</a></li>
<li class="last comment_forbidden"><span class="comment_forbidden">要发表评论，请先<a href="/main/user/login?destination=comment/reply/135%2523comment-form">登录</a> 或 <a href="/main/user/register?destination=comment/reply/135%2523comment-form">注册</a></span></li>
</ul></div>
</div>
<div id="comments"><a id="comment-1344"></a>
<div class="comment">
 <h3 class="title"><a href="/main/node/135#comment-1344" class="active">很难找到这么好的文章了</a></h3>
 <div class="content"><p>很难找到这么好的文章了！！！强烈感谢楼主的无私！！</p>
</div>
 <div class="links"><ul class="links"><li class="first comment_submitted"><span class="comment_submitted">由 Anonymous (未验证) 在 2007/06/20 - 09:37 发表</span></li>
<li class="last comment_forbidden"><span class="comment_forbidden">要发表评论，请先<a href="/main/user/login?destination=comment/reply/135%2523comment-form">登录</a> 或 <a href="/main/user/register?destination=comment/reply/135%2523comment-form">注册</a></span></li>
</ul></div>
</div>
<a id="comment-328"></a>
<div class="comment">
 <h3 class="title"><a href="/main/node/135#comment-328" class="active">出现拉问题</a></h3>
 <div class="content"><p>为了将目录永久添加到您的 $PATH ，只要将'export'的那行添加到您的'.bash_profile'文件中。<br />
我是按照这句话去做的但是没有用<br />
我想把~/software/LumaQQ/lumaqq 永远的加到PATH里面<br />
我是把export PATH=$PATH:~/software/LumaQQ/ 用vi加到拉.bash_profile的最后一行,但是我输入lumaqq的时候没有起动 提示没有这个命令<br />
    这是怎么回事?  我也把上面的export去掉拉 直接把PATH=$PATH:~/software/LumaQQ/ 加到拉.bash_profile的最后一行,也没有用<br />
请高手指教   及</p>
</div>
 <div class="links"><ul class="links"><li class="first comment_submitted"><span class="comment_submitted">由 lx 在 2006/03/31 - 15:11 发表</span></li>
<li class="last comment_forbidden"><span class="comment_forbidden">要发表评论，请先<a href="/main/user/login?destination=comment/reply/135%2523comment-form">登录</a> 或 <a href="/main/user/register?destination=comment/reply/135%2523comment-form">注册</a></span></li>
</ul></div>
</div>
<div class="indented"><a id="comment-841"></a>
<div class="comment">
 <h3 class="title"><a href="/main/node/135#comment-841" class="active">谢谢</a></h3>
 <div class="content"><p>谢谢，分享文章！</p>
</div>
 <div class="links"><ul class="links"><li class="first comment_submitted"><span class="comment_submitted">由 LinuxSir 在 2006/10/31 - 11:54 发表</span></li>
<li class="last comment_forbidden"><span class="comment_forbidden">要发表评论，请先<a href="/main/user/login?destination=comment/reply/135%2523comment-form">登录</a> 或 <a href="/main/user/register?destination=comment/reply/135%2523comment-form">注册</a></span></li>
</ul></div>
</div>
<a id="comment-557"></a>
<div class="comment">
 <h3 class="title"><a href="/main/node/135#comment-557" class="active">修改完.bash_profile之后执行命令</a></h3>
 <div class="content"><p>修改完.bash_profile之后执行命令>. .bash_profile</p>
</div>
 <div class="links"><ul class="links"><li class="first comment_submitted"><span class="comment_submitted">由 Anonymous (未验证) 在 2006/07/15 - 00:52 发表</span></li>
<li class="last comment_forbidden"><span class="comment_forbidden">要发表评论，请先<a href="/main/user/login?destination=comment/reply/135%2523comment-form">登录</a> 或 <a href="/main/user/register?destination=comment/reply/135%2523comment-form">注册</a></span></li>
</ul></div>
</div>
</div></div>
<!-- end content -->
 <div id="footer"><center>
<a href="http://www.linuxsir.org"><img src="http://www.linuxsir.org/main/logo.jpg"></a> <br>

<a href="http://www.miibeian.gov.cn" target="_blank"><font size=3 color=blue><b> 闽ICP备06025536号</b></font></a><br>

<br>
<a href="?q=node/78"><font size=3 color=blue><b> © 2002-2007 LinuxSir.Org</b></font></a><br>
</center></div>
   </td>
   <td id="sidebar-right"><div class="block block-block" id="block-block-2">
 <h2 class="title">基础知识</h2>
 <div class="content"><ul>
<li><a href="?q=taxonomy/term/23">安装配置</a>
<li><a href="?q=taxonomy/term/1/25/">基础入门</a>
<li><a href="?q=taxonomy/term/22/">硬件解决</a>
<li><a href="?q=taxonomy/term/21">软件管理</a>
<li><a href="?q=taxonomy/term/35/48/">重要资源</a>
</ul></div>
</div>
<div class="block block-block" id="block-block-4">
 <h2 class="title">软件应用</h2>
 <div class="content"><ul>
<li><a href="?q=taxonomy/term/30">网络工具</a>
<li><a href="?q=taxonomy/term/32">图形图像</a>
<li><a href="?q=taxonomy/term/31">音乐视频</a>
<li><a href="?q=taxonomy/term/49">字体中文</a>
<li><a href="?q=taxonomy/term/33">软件其它</a>
</ul>
</div>
</div>
<div class="block block-block" id="block-block-5">
 <h2 class="title">网络服务器</h2>
 <div class="content"><ul>
<li><a href="?q=taxonomy/term/27">文件服务器<a>
<li><a href="?q=taxonomy/term/28">Web服务器</a>
<li><a href="?q=taxonomy/term/29">邮件服务器</a>
<li><a href="?q=taxonomy/term/37">数据库应用</a>
<li><a href="?q=taxonomy/term/50">服务器其它</a>
</ul>
</div>
</div>
<div class="block block-comment" id="block-comment-0">
 <h2 class="title">最新评论</h2>
 <div class="content"><div class="item-list"><ul><li><a href="/main/node/291#comment-1987">linux有迅雷吗？</a><br />12 周 3 天 前</li><li><a href="/main/node/291#comment-1986">我下载32位的DVD，迅雷</a><br />12 周 3 天 前</li><li><a href="/main/node/295#comment-1985">我来上学的。</a><br />13 周 2 天 前</li><li><a href="/main/node/296#comment-1984">幸会幸会</a><br />13 周 4 天 前</li><li><a href="/main/node/228#comment-1983">恭喜恭喜…………
天</a><br />13 周 6 天 前</li><li><a href="/main/node/295#comment-1982">终于回来了！！！一</a><br />13 周 6 天 前</li><li><a href="/main/node/228#comment-1981">恭喜~</a><br />14 周 4 天 前</li><li><a href="/main/node/140#comment-1980">非常不错的一本书，</a><br />15 周 1 天 前</li><li><a href="/main/node/285#comment-1979">配置后所有字体都没</a><br />15 周 2 天 前</li><li><a href="/main/node/295#comment-1978">我n年前的账户现在登陆不了怎么回事？</a><br />15 周 6 天 前</li></ul></div></div>
</div>
</td>
  </tr>
 </table>
 </body>
</html>
