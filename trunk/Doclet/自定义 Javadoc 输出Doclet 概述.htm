<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=gb2312">
<title>Doclet 概述</title>
</head>

<body BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#000077" ALINK="#FF0000">

<table BORDER="0" WIDTH="100%">
  <tr>
    <td WIDTH="60"><img SRC="../../images/javalogo52x88.gif" ALT="Java" BORDER="0" WIDTH="52"
    HEIGHT="88"> </td>
    <td><h1>Doclet 概述</h1>
    </td>
  </tr>
</table>
<!-- Body text begins here -->

<h2>目录</h2>

<ul>
  <li><a href="#basics">基础</a> </li>
  <li><a href="#simple">简单示例</a> </li>
  <li><a href="#custom">自定义 Javadoc 输出</a> <ul>
      <li><a href="#tags">示例 - 创建和处理自定义标记</a> </li>
      <li><a href="#options">示例 - 使用自定义命令行选项</a> </li>
    </ul>
  </li>
</ul>

<p><a name="basics"></a></p>

<h2>基础</h2>

<p>Doclet 是用 Java<font size="-2"><sup>TM</sup> </font>编程语言编写的程序，它用 
<a href="doclet/index.html">doclet API</a> 指定 Javadoc 
工具的输出内容和格式。缺省情况下，Javadoc 工具用 Sun<font size="-2"><sup>TM</sup></font> 
提供的<a href="standard-doclet.html">“标准”</a>doclet 来生成 HTML 形式的 
API 文档。然而，用户也可用自己的 doclet 根据个人喜好自定义 Javadoc 
输出。用户可以利用 doclet API从头开始编写 doclet，也可以对标准 
doclet 进行修改，以适合自己的需要。</p>

<p>下面是创建和使用自己的 doclet 的基本步骤： 

<ol>
  <li>编写用来构成 doclet 的 Java 程序。为使用 doclet API，该程序应导入 
    com.sun.javadoc.*。程序的入口点是一个带有 <tt>public static boolean start</tt> 
    方法的类，它将 <a href="doclet/com/sun/javadoc/RootDoc.html">RootDoc</a> 
    作为参数。</li>
  <li>编译 doclet。可以使用 Java Development Kit 的编译器 javac 来编译它。</li>
  <li>用 <b><tt>-doclet <i>&lt;YourDoclet&gt;</i></tt></b> 选项运行 javadoc 
    工具，生成 doclet 指定的输出。</li>
</ol>

<p>doclet API 类文件在 JDK 软件的 <tt>lib/tools.jar</tt> 文件中。当编译 
doclet 和使用自定义 doclet 时，<tt>tools.jar</tt> 
必须在类路径上。为此，可以对 javac 和 javadoc 使用 <tt>-classpath</tt> 
选项。</p>

<p>如果运行 javadoc 时未使用 <tt>-doclet</tt> 
命令行选项，则按缺省状态的标准 doclet 生成 HTML 格式的 API 文档。</p>

<p>包 com.sun.javadoc 由定义 doclet API 的接口组成。JDK<font size="-2"><sup>TM</sup></font> 
软件的 <tt>lib/tools.jar</tt> 
文件包含这些接口及实现这些接口的类的私有包。<tt>tools.jar</tt> 
文件还包括实现标准 doclet 的类。<a name="simple"></a> </p>

<h2>简单示例</h2>

<p>参看下面由一个短类组成的简单示例 doclets，您可以对 doclets 
的运行方式有所了解： </p>

<blockquote><pre>
import <a href="doclet/com/sun/javadoc/package-summary.html">com.sun.javadoc.*</a>;

public class ListClass {
    public static boolean start(<a href="doclet/com/sun/javadoc/RootDoc.html">RootDoc</a> root) {
        <a href="doclet/com/sun/javadoc/ClassDoc.html">ClassDoc</a>[] classes = root.<a href="doclet/com/sun/javadoc/RootDoc.html#classes()">classes()</a>;
        for (int i = 0; i < classes.length; ++i) {
            System.out.println(classes[i]);
        }
        return true;
    }
}
</blockquote></pre>

<p>通过查看代码，不难猜到：该 doclet 将取出 Javadoc 
所操作的一些类，然后将它们的名称输到标准输出上。</p>

<p>就该 doclet 而言，首先应注意到：为使用 doclet API，程序导入了 
com.sun.javadoc.*。对于所有 doclets，入口点均为 <tt>public static boolean start</tt> 
方法。<tt>start</tt> 方法将 RootDoc 作为参数使用。该参数携带运行 
javadoc 时命令行指定的所有选项信息，以及 Javadoc 
所操作的类和包的信息。</p>

<p>RootDoc 定义返回 ClassDoc 数组的 classes 方法，其中数组的元素代表 
Javadoc 解析的类。随后，<tt>for</tt> 循环输出数组中每个类的名称（将 
ClassDoc 传给 <tt>println</tt> 将输出 ClassDoc 代表的类名）。 </p>

<p>运行该 doclet 前，必须先进行编译。可以用 JDK javac 
编译器来编译它。API 类文件在 JDK 软件的文件 <tt>lib/tools.jar</tt> 
中，因此编译器的 classpath 中需包括 <tt>tools.jar</tt>，对本例如下所示： 
</p>

<blockquote>
  <pre>
javac -classpath C:\jdk1.2\lib\tools.jar ListClass.java
</pre>
</blockquote>

<p>为运行 ListClass doclet，您必须用 Javadoc 的 <tt>-doclet</tt> 
标记指向编译后的 doclet。例如，要在文件 <tt>MyClass.java</tt> 上运行 
doclet，需使用命令： </p>

<blockquote>
  <pre>
% javadoc -doclet ListClass -classpath C:\jdk1.2\lib\tools.jar MyClass.java
</pre>
</blockquote>

<p>输出结果将是字符串 &quot;<tt>MyClass</tt>&quot;。注意：该命令也要求类路径中包含 
<tt>tools.jar</tt>。</p>

<p>关于命令行选项的说明：如果运行 <tt>javadoc -help</tt>，就会看到 
Javadoc 
工具有两个命令行选项集。一个选项集是普通选项集，它适用于任何 
doclet。另一个则专门用于标准 doclet。使用自定义 doclets 
时，将不能使用第二个选项集。自定义 doclets 
可以定义自己的命令行选项。参阅下面的<a href="#options">示例</a>。</p>

<p>要生成 API 文档，doclet 将会比该示例要复杂得多。如果想自定义 
Javadoc 生成的 API 文档格式，可能应该从缺省标准 doclet 
起步，必要时对其进行修改，而不是完全从头开始编写 doclet。<a
name="custom"></a> </p>

<h2>自定义 Javadoc 输出</h2>

<p>为了自定义 Javadoc 工具的输出，需要编写自己的 doclet，用于指定所需的输出格式和内容。如果希望 
HTML 输出与缺省的输出大体相同，则可以用标准 doclet 作为创建 doclet 
的起点。您可以在标准 doclet 
中扩展相应的类，必要时添加或覆盖方法，以生成符合要求的输出。也可以复制整个标准 
doclet 并进行修改。假如以标准 doclet 
的副本为起点，就要删除每个源文件开始位置的<tt> package</tt> 
语句，并将这些语句改为自己的新包的名称。</p>

<p><!--
As a trivial example, suppose you want to customize the HTML
output generated by Javadoc so that the horizontal rules were
bolder and thicker than the default horizonal rules in the
standard output.
How would you go about modifying the APIs in the standard doclet to
produce these to changes?  Because the customization in question
involves a change in the HTML formatting, the above <a href="#api">API
summary</a> suggests that
you might need to modify the APIs in class <tt>HtmlWriter</tt>.
If you look at the <a href="source/HtmlWriter.java">source</a> for
the HtmlWriter class, you will find methods for writing the HTML
tags used in generating the default HTML documentation. Among these,
there is a method for writing the HTML tag for horizonal rules:
<blockquote><pre>
public void hr() {
    println("&lt;hr&gt;");
}
</pre></blockquote>
You'll also notice that the HtmlWriter class doesn't provide a
way to produce the custom horizontal rules that you want. You can
therefore add a method to HtmlWriter, or an HtmlWriter subclass, that
prints the custom tag that you want. For example, you might
add this method:
<blockquote><pre>
public void hrCustom() {
    println("&lt;hr size=3 noshade&gt;");
}
</pre></blockquote>
and call it instead of the <tt>hr</tt> method when you want to
your output to use the thicker horizontal rules.
<p>
--> <a name="tags"></p>

<h3>示例 - 创建和处理自定义标记</h3>
</a>

<p>假定在文档注释中除标准标记（例如 <tt>@param</tt> 和 <tt>@return</tt>）之外，您还想使用自定义标记 
<tt>@mytag</tt>。为了利用自定义标记的信息，需要在自己的 doclet 
中使用代表自定义标记的 <a href="doclet/com/sun/javadoc/Tag.html"><tt>Tag</tt></a> 
的实例。为此，最简单的办法是使用 <tt>Doc</tt> 或 <tt>Doc</tt> 子类的 <a
href="doclet/com/sun/javadoc/Doc.html#tags(java.lang.String)"><tt>tags(String)</tt></a> 
方法。该方法返回 <tt>Tag</tt> 
数组，代表其名称与字符串参数匹配的所有标记。例如，如果 <tt>method</tt> 
是 <tt>MethodDoc</tt> 的实例，那么 </p>

<blockquote>
  <pre>
method.tags(&quot;mytag&quot;)
</pre>
</blockquote>

<p>将返回 <tt>Tag</tt> 对象的数组，它代表该方法文档注释中的所有 <tt>@mytag</tt> 
标记。然后即可用 <tt>Tag</tt> 的 <a href="doclet/com/sun/javadoc/Tag.html#text()"><tt>text</tt></a> 
方法访问 <tt>@mytag</tt> 
标记的信息。此方法将返回一个字符串，代表必要时可以解析或使用的标记的内容。例如，如果文档注释包含的自定义标签为： 
</p>

<blockquote>
  <pre>
@mytag Some dummy text.
</pre>
</blockquote>

<p>则 <tt>text</tt> 方法将返回字符串 <tt>&quot;Some dummy text.&quot;</tt>。 </p>

<p>下面的 doclet 
即使用上述思想输出它查找到的特定标记的所有实例中所包含的内容： 
</p>

<blockquote><pre>
import com.sun.javadoc.*;

public class ListTags {
    public static boolean start(RootDoc root){ 
        String tagName = "mytag";
        writeContents(root.classes(), tagName);
        return true;
    }

    private static void writeContents(ClassDoc[] classes, String tagName) {
        for (int i=0; i < classes.length; i++) {
            boolean classNamePrinted = false;
            MethodDoc[] methods = classes[i].methods();
            for (int j=0; j < methods.length; j++) {
                Tag[] tags = methods[j].tags(tagName);
                if (tags.length > 0) {
                    if (!classNamePrinted) {
                        System.out.println("\n" + classes[i].name() + "\n");
                        classNamePrinted = true;
                    }
                    System.out.println(methods[j].name());
                    for (int k=0; k < tags.length; k++) {
                        System.out.println("   " + tags[k].name() + ": " 
                            + tags[k].text());
                    }
                } 
            }
        }
    }
}
</pre></blockquote>

<pre>doclet 所查找的标记由变量 <tt>tagName</tt> 指定。字符串<tt> tagName</tt> 的值可以是自定义或标准的任意标记名。
该 doclet 将写到标准输出，但它的输出格式是可以修改的。例如，可以将 HTML 输出写到文件中。

<a
name="options">
</pre>

<h3>示例 - 使用自定义命令行选项</h3>
</a>

<pre>用户可以编写接受自定义命令行选项的 doclets。为了解其工作原理，不妨让我们扩充一下上面的 doclet
示例，使它可以允许用户用命令行选项指定要查找的标记名。
</pre>

<p>任何使用自定义选项的 doclet 必须有一个名为 <tt>optionLength(String 
option)</tt> 的方法，该方法返回 <tt>int</tt>。对于想要 doclet 
识别的每个自定义选项，<tt>optionLength</tt> 
必须返回选项的组成部分数或符号数。示例中，我们想使用 <tt>-tag 
mytag</tt> 形式的自定义选项。该选项有两个部分：<tt>-tag</tt> 
选项自身及其值。因此 doclet 中的 <tt>optionLength</tt> 方法必须为 <tt>-tag</tt> 
选项返回 <tt>2</tt>。对于无法识别的选项，<tt>optionsLength</tt> 
方法应返回 <tt>0</tt>。</p>

<p>下面是整个扩充后的 doclet： </p>

<blockquote><pre>
import com.sun.javadoc.*;

public class ListTags {
    public static boolean start(RootDoc root){ 
        String tagName = readOptions(root.options());
        writeContents(root.classes(), tagName);
        return true;
    }

    private static void writeContents(ClassDoc[] classes, String tagName) {
        for (int i=0; i < classes.length; i++) {
            boolean classNamePrinted = false;
            MethodDoc[] methods = classes[i].methods();
            for (int j=0; j < methods.length; j++) {
	        Tag[] tags = methods[j].tags(tagName);
	        if (tags.length > 0) {
	            if (!classNamePrinted) {
	                System.out.println("\n" + classes[i].name() + "\n");
	                classNamePrinted = true;
	            }
	            System.out.println(methods[j].name());
	            for (int k=0; k < tags.length; k++) {
	                System.out.println("   " + tags[k].name() + ": " + tags[k].text());
	            }
	        } 
	    }
        }
    }

    private static String readOptions(String[][] options) {
        String tagName = null;
        for (int i = 0; i < options.length; i++) {
            String[] opt = options[i];
	    if (opt[0].equals("-tag")) {
	        tagName = opt[1];
	    }
        }
	return tagName;
    }

    public static int optionLength(String option) {
        if(option.equals("-tag")) {
	    return 2;
        }
        return 0;
    }

    public static boolean validOptions(String options[][], 
				       DocErrorReporter reporter) {
	boolean foundTagOption = false;
        for (int i = 0; i < options.length; i++) {
            String[] opt = options[i];
            if (opt[0].equals("-tag")) {
	        if (foundTagOption) {
	            reporter.printError("Only one -tag option allowed.");
		    return false;
	        } else { 
		    foundTagOption = true;
		}
	    } 
	}
	if (!foundTagOption) {
	    reporter.printError("Usage: javadoc -tag mytag -doclet ListTags ...");
	}
	return foundTagOption;
    }
}
</pre></blockquote>
<pre>在修改后的 doclet 中，变量 <tt>tagName</tt> 是用命令行选项 <tt>-tag</tt> 设置的。对于自定义选项，它的 <tt>optionLength
</tt>方法返回 2。注意：这里并不需要 <tt>optionLength</tt> 的显式调用。
</pre>

<p>该 doclet 还增加了 <tt>readOptions</tt> 
方法，用于解析命令行选项以查找 <tt>-tag</tt> 
选项。它所利用的是这样一个事实：<a
href="doclet/com/sun/javadoc/RootDoc.html#options()"><tt>Rootdoc.options</tt></a> 
方法返回包含选项信息的二维 String 数组。例如，假定命令为： </p>

<blockquote>
  <pre>
javadoc -foo this that -bar other ...
</pre>
</blockquote>
<tt>

<pre>RootDoc.options</tt> 方法将返回
</pre>

<blockquote>
  <pre>
options()[0][0] = &quot;-foo&quot;
options()[0][1] = &quot;this&quot;
options()[0][2] = &quot;that&quot;
options()[1][0] = &quot;-bar&quot;
options()[1][1] = &quot;other&quot;
</pre>
</blockquote>

<pre>数组第二个下标中的元素个数由 <tt>optionLength</tt> 方法决定。本例中，对于选项 <tt>-foo</tt>，<tt>optionLength</tt> 返回 <tt>3</tt>；</pre>

<pre>对于选项 <tt>-bar</tt>，则返回 <tt>2</tt>。
</pre>

<p><tt>validOptions</tt> 
方法为可选方法，可以用来测试命令行标记用法的有效性。如果 <tt>validOptions</tt> 
方法存在，就会被自动调用，而无需显式调用。如果选项用法有效，则该方法应返回 
<tt>true</tt>，否则返回 <tt>false</tt>。当发现命令行选项的使用不正确时，还可从 
<tt>validOptions</tt> 输出相应的错误信息。该示例 doclet 的 <tt>validOptions</tt> 
方法检查是否使用了 <tt>-tag</tt> 选项以及是否仅使用了一次。</p>

<p><!-- Body text ends here --> <!-- ============================================================== --> </p>

<hr SIZE="3" NOSHADE>

<table BORDER="0" WIDTH="100%">
  <tr VALIGN="TOP">
    <td><font size="-2"><a HREF="../../relnotes/SMICopyright.html">版权所有 &copy;</a> 
    1995-98 <a HREF="http://www.sun.com/">Sun Microsystems, Inc.</a> 保留所有权利。</font><p><font
    SIZE="-1">如有意见，请发送至：<a href="mailto:javadoc-tool@sun.com">javadoc-tool@sun.com</a> 
    </font></td>
    <td ALIGN="RIGHT"><img SRC="../../images/sunlogo64x30.gif" ALT="Sun" BORDER="0" WIDTH="64"
    HEIGHT="30"> </td>
  </tr>
</table>
</body>
</html>
