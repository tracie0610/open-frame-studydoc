<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Application: TSS Portal -->
<!-- Page: Article -->
<!-- Generated: Mon Aug 17 02:58:07 EDT 2009 -->
<html>
<head>
<meta name="generator" content="Tapestry Application Framework, version 3.0.1"/>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Enterprise Java Community: Introduction to the Spring Framework 2.5</title>
<link rel="stylesheet" type="text/css" href="/tt/skin/style/sitestyle.css"/>
<link rel="stylesheet" type="text/css" href="/tt/style/tapestry.css"/>
</head>

<body>
<script language="JavaScript" type="text/javascript" src="/assets/org/apache/tapestry/valid/Validator.js"></script>
<script language="JavaScript"><!--

var tapestry_preload = new Array();
if (document.images)
{
  tapestry_preload[0] = new Image();
  tapestry_preload[0].src = "/tt/skin/images/tab_news_mo.gif";
  tapestry_preload[1] = new Image();
  tapestry_preload[1].src = "/tt/skin/images/tab_news.gif";
  tapestry_preload[2] = new Image();
  tapestry_preload[2].src = "/tt/skin/images/tab_blog_mo.gif";
  tapestry_preload[3] = new Image();
  tapestry_preload[3].src = "/tt/skin/images/tab_blog.gif";
  tapestry_preload[4] = new Image();
  tapestry_preload[4].src = "/tt/skin/images/tab_discussions_mo.gif";
  tapestry_preload[5] = new Image();
  tapestry_preload[5].src = "/tt/skin/images/tab_discussions.gif";
  tapestry_preload[6] = new Image();
  tapestry_preload[6].src = "/tt/skin/images/tab_techtalks_mo.gif";
  tapestry_preload[7] = new Image();
  tapestry_preload[7].src = "/tt/skin/images/tab_techtalks.gif";
  tapestry_preload[8] = new Image();
  tapestry_preload[8].src = "/tt/skin/images/tab_whitepapers_mo.gif";
  tapestry_preload[9] = new Image();
  tapestry_preload[9].src = "/tt/skin/images/tab_whitepapers.gif";
  tapestry_preload[10] = new Image();
  tapestry_preload[10].src = "/tt/skin/images/tab_itdownloads_mo.gif";
  tapestry_preload[11] = new Image();
  tapestry_preload[11].src = "/tt/skin/images/tab_itdownloads.gif";
  tapestry_preload[12] = new Image();
  tapestry_preload[12].src = "/tt/skin/images/tab_patterns_mo.gif";
  tapestry_preload[13] = new Image();
  tapestry_preload[13].src = "/tt/skin/images/tab_patterns.gif";
  tapestry_preload[14] = new Image();
  tapestry_preload[14].src = "/tt/skin/images/tab_reviews_mo.gif";
  tapestry_preload[15] = new Image();
  tapestry_preload[15].src = "/tt/skin/images/tab_reviews.gif";
  tapestry_preload[16] = new Image();
  tapestry_preload[16].src = "/tt/skin/images/tab_articles_mo.gif";
  tapestry_preload[17] = new Image();
  tapestry_preload[17].src = "/tt/skin/images/tab_articles_sel.gif";
  tapestry_preload[18] = new Image();
  tapestry_preload[18].src = "/tt/skin/images/tab_feeds_mo.gif";
  tapestry_preload[19] = new Image();
  tapestry_preload[19].src = "/tt/skin/images/tab_feeds.gif";
  tapestry_preload[20] = new Image();
  tapestry_preload[20].src = "/tt/skin/images/tab_about_mo.gif";
  tapestry_preload[21] = new Image();
  tapestry_preload[21].src = "/tt/skin/images/tab_about.gif";
}




function focus_rollover()
{
  if (document.images)
    document.rollover.src = tapestry_preload[0].src;
}

function blur_rollover()
{
  if (document.images)
    document.rollover.src = tapestry_preload[1].src;
}



function focus_rollover$0()
{
  if (document.images)
    document.rollover$0.src = tapestry_preload[2].src;
}

function blur_rollover$0()
{
  if (document.images)
    document.rollover$0.src = tapestry_preload[3].src;
}



function focus_rollover$1()
{
  if (document.images)
    document.rollover$1.src = tapestry_preload[4].src;
}

function blur_rollover$1()
{
  if (document.images)
    document.rollover$1.src = tapestry_preload[5].src;
}



function focus_rollover$2()
{
  if (document.images)
    document.rollover$2.src = tapestry_preload[6].src;
}

function blur_rollover$2()
{
  if (document.images)
    document.rollover$2.src = tapestry_preload[7].src;
}



function focus_rollover$3()
{
  if (document.images)
    document.rollover$3.src = tapestry_preload[8].src;
}

function blur_rollover$3()
{
  if (document.images)
    document.rollover$3.src = tapestry_preload[9].src;
}



function focus_rollover$4()
{
  if (document.images)
    document.rollover$4.src = tapestry_preload[10].src;
}

function blur_rollover$4()
{
  if (document.images)
    document.rollover$4.src = tapestry_preload[11].src;
}



function focus_rollover$5()
{
  if (document.images)
    document.rollover$5.src = tapestry_preload[12].src;
}

function blur_rollover$5()
{
  if (document.images)
    document.rollover$5.src = tapestry_preload[13].src;
}



function focus_rollover$6()
{
  if (document.images)
    document.rollover$6.src = tapestry_preload[14].src;
}

function blur_rollover$6()
{
  if (document.images)
    document.rollover$6.src = tapestry_preload[15].src;
}



function focus_rollover$7()
{
  if (document.images)
    document.rollover$7.src = tapestry_preload[16].src;
}

function blur_rollover$7()
{
  if (document.images)
    document.rollover$7.src = tapestry_preload[17].src;
}


function validate_inputEmail()
{
  var field = document.Form0.inputEmail;

  if (field.value.length == 0)
     return validator_invalid_field(field, "You must enter a value for E-Mail.");





  return true;
}

function validate_inputPassword()
{
  var field = document.Form0.inputPassword;

  if (field.value.length == 0)
     return validator_invalid_field(field, "You must enter a value for Password.");





  return true;
}


function focus_feedsRollover()
{
  if (document.images)
    document.feedsRollover.src = tapestry_preload[18].src;
}

function blur_feedsRollover()
{
  if (document.images)
    document.feedsRollover.src = tapestry_preload[19].src;
}



function focus_aboutRollover()
{
  if (document.images)
    document.aboutRollover.src = tapestry_preload[20].src;
}

function blur_aboutRollover()
{
  if (document.images)
    document.aboutRollover.src = tapestry_preload[21].src;
}



window.onload = function ()
{
document.Form0.inputEmail.focus();
document.Form0.inputEmail.select();
document.Form0.onsubmit = function ()
{

  return validate_inputEmail() &&
    validate_inputPassword();
}



var styleclass_inputEmail = document.Form0.inputEmail.className;

document.Form0.inputEmail.onblur = function()
{
  var field = document.Form0.inputEmail;
  field.className = styleclass_inputEmail;
  
  if (field.value == '') field.value = 'email';
}

document.Form0.inputEmail.onfocus = function()
{
  var field = document.Form0.inputEmail;
  field.className = 'focus';
  
  if (field.value == 'email') field.value = '';
}

if (document.Form0.inputEmail.value == '') document.Form0.inputEmail.value = 'email';


var styleclass_inputPassword = document.Form0.inputPassword.className;

document.Form0.inputPassword.onblur = function()
{
  var field = document.Form0.inputPassword;
  field.className = styleclass_inputPassword;
  
  if (field.value == '') field.value = 'password';
}

document.Form0.inputPassword.onfocus = function()
{
  var field = document.Form0.inputPassword;
  field.className = 'focus';
  
  if (field.value == 'password') field.value = '';
}

if (document.Form0.inputPassword.value == '') document.Form0.inputPassword.value = 'password';

}

// --></script>
<script src="/tt/skin/script/openwindow.js" language="javascript"></script>
<!--WEBSIDESTORY CODE HBX1.0 (Universal)--
<!--COPYRIGHT 1997-2004 WEBSIDESTORY,INC. ALL RIGHTS RESERVED. U.S.PATENT No.6,393,479B1 & 6,766,370. INFO:http://websidestory.com/privacy-->
<script language="javascript">

var _hbEC=0,_hbE=new Array;function _hbEvent(a,b){b=_hbE[_hbEC++]=new Object();b._N=a;b._C=0;return b;}
var hbx=_hbEvent("pv");hbx.vpc="HBX0103u";hbx.gn="ehg-techtarget.hitbox.com";

function getURLParam(param) {
	param = param.toLowerCase() + "=";
	var paramq = "?" + param;
	var parama = "&" + param;
	var wls = "?" + window.location.search.toLowerCase();
	if (wls.indexOf(paramq) != -1) wls = wls.substring(wls.indexOf(paramq),wls.length); //first search value
	if (wls.indexOf(parama) != -1) wls = wls.substring(wls.indexOf(parama),wls.length); //any other search value
	wls = wls.substring(1, wls.length); //remove leading ? or &
	if (wls.indexOf("&") != -1) wls = wls.substring(0,wls.indexOf("&")); //remove any additional values
	return wls;
}
function urlParamExists(param) {
	param = param.toLowerCase() + "=";
	var result = false;
	var paramq = "?" + param;
	var parama = "&" + param;
	var wls = "?" + window.location.search.toLowerCase();
	if (wls.indexOf(paramq) != -1 || wls.indexOf(parama) != -1) result = true;
	return result;
}

//BEGIN EDITABLE SECTION
//CONFIGURATION VARIABLES
hbx.acct="DM54121089AE83EN3;DM5212204PCA83EN3";//ACCOUNT NUMBER(S)

//PAGENAME
var wlp = window.location.pathname.toLowerCase().substring(1,window.location.pathname.length);
var spn = "";
if (window.location.search) {
	spn = window.location.search;
	spn = spn.replace(/\?/g, "--");
	spn = spn.replace(/&/g, "-");
}
hbx.pn=(wlp.length < 2) ? "home" : wlp;//PAGE NAME(S)
hbx.pn = hbx.pn.replace(eval("/\\//g"),"-");
hbx.pn += spn; //add in any search params
hbx.pndef="title";//DEFAULT PAGE NAME

//MULTI-LEVEL CONTENT
hbx.mlc="/theServerSideCom";
if (wlp.length > 1) hbx.mlc += "/" + wlp.substring(0,wlp.indexOf("/", 1));//MULTI-LEVEL CONTENT CATEGORY
hbx.ctdef="full";//DEFAULT CONTENT CATEGORY

//OPTIONAL PAGE VARIABLES
//ACTION SETTINGS
hbx.fv="";//FORM VALIDATION MINIMUM ELEMENTS OR SUBMIT FUNCTION NAME
hbx.lt="none";//LINK TRACKING
hbx.dlf="n";//DOWNLOAD FILTER
hbx.dft="n";//DOWNLOAD FILE NAMING
hbx.elf="n";//EXIT LINK FILTER

//SEGMENTS AND FUNNELS
hbx.seg="";//VISITOR SEGMENTATION
hbx.fnl="";//FUNNELS

//CAMPAIGNS
hbx.cmp="";//CAMPAIGN ID
hbx.cmpn="";//CAMPAIGN ID IN QUERY
hbx.dcmp="";//DYNAMIC CAMPAIGN ID
hbx.dcmpn="";//DYNAMIC CAMPAIGN ID IN QUERY
hbx.dcmpe="";//DYNAMIC CAMPAIGN EXPIRATION
hbx.dcmpre="";//DYNAMIC CAMPAIGN RESPONSE EXPIRATION
hbx.hra="";//RESPONSE ATTRIBUTE
hbx.hqsr="";//RESPONSE ATTRIBUTE IN REFERRAL QUERY
hbx.hqsp="";//RESPONSE ATTRIBUTE IN QUERY
hbx.hlt="";//LEAD TRACKING
hbx.hla="";//LEAD ATTRIBUTE
hbx.gp="";//CAMPAIGN GOAL
hbx.gpn="";//CAMPAIGN GOAL IN QUERY
hbx.hcn="";//CONVERSION ATTRIBUTE
hbx.hcv="";//CONVERSION VALUE
hbx.cp="null";//LEGACY CAMPAIGN
hbx.cpd="";//CAMPAIGN DOMAIN

//CUSTOM VARIABLES
hbx.ci="";//CUSTOMER ID
hbx.hc1="";//CUSTOM 1
hbx.hc2="";//CUSTOM 2
hbx.hc3="";//CUSTOM 3
hbx.hc4="";//CUSTOM 4
hbx.hrf="";//CUSTOM REFERRER
hbx.pec="";//ERROR CODES

//INSERT CUSTOM EVENTS
if (window.location.search.indexOf('wrTest=on') != -1) window.alert(hbx.pn + " :: " + hbx.mlc + " :: " + wlp);
//END EDITABLE SECTION
</script>
<script language="javascript1.1" src="/tt/skin/script/hbx.js"></script>
<!--END WEBSIDESTORY CODE-->
<script src="/tt/skin/script/dart.js" language="javascript"></script>

<script src="/tt/skin/script/doubleclickad.js" language="javascript"></script>

<table cellspacing="0" class="head">
<tr>
<td class="left" NORWRAP style="white-space:nowrap" valign="top"><a href="/" class="nodecoration" title="Go to the front page news"><img src="/tt/skin/images/header_logotype.gif" width="321" height="72" border="0"/><img src="/tt/skin/images/header_div.gif" width="71" height="72" border="0"/></a></td>
<td class="right" valign="middle"><!-- begin ZEDO -->  
     <script type="text/javascript">          
        if ( typeof renderDartAd == "function" )   
            renderDartAd( /* textAdNumber */ 1,
                          /* adWidth */  468 ,
                          /* adHeight */ 60 ,
                          /* iHeight */  60 ,
                          /* adColor */  "FFFFFF",
                          /* showSpacer*/ false);
    </script>
<!-- end ZEDO -->
</td>
<td valign="top"><img src="/tt/skin/images/header_endbar.gif" width="6" height="72"/></td>
</tr>
</table>
<table cellspacing="0" class="tabs">
  <tr><td colspan="2"><img src="/tt/images/spacer.gif" width="1" height="1"/></td></tr>
  <tbody>
    <tr>	
        <td class="menuimages" style="white-space:nowrap;"><a href="/" onMouseOver="javascript:focus_rollover();" onMouseOut="javascript:blur_rollover();" title="News"><img src="/tt/skin/images/tab_news.gif" border="0" name="rollover" height="57" vspace="0" width="43"/></a><a href="/blogs/index.tss" onMouseOver="javascript:focus_rollover$0();" onMouseOut="javascript:blur_rollover$0();" title="Blogs"><img src="/tt/skin/images/tab_blog.gif" border="0" name="rollover$0" height="57" vspace="0" width="49"/></a><a href="/discussions/index.tss" onMouseOver="javascript:focus_rollover$1();" onMouseOut="javascript:blur_rollover$1();" title="Discussions"><img src="/tt/skin/images/tab_discussions.gif" border="0" name="rollover$1" height="57" vspace="0" width="63"/></a><a href="/talks/index.tss" onMouseOver="javascript:focus_rollover$2();" onMouseOut="javascript:blur_rollover$2();" title="Tech talks"><img src="/tt/skin/images/tab_techtalks.gif" border="0" name="rollover$2" height="57" vspace="0" width="55"/></a><a href="http://library.theserverside.com/" onMouseOver="javascript:focus_rollover$3();" onMouseOut="javascript:blur_rollover$3();" title="White Papers"><img src="/tt/skin/images/tab_whitepapers.gif" border="0" name="rollover$3" height="57" vspace="0" width="64"/></a><a href="http://library.theserverside.com/itdownloads" onMouseOver="javascript:focus_rollover$4();" onMouseOut="javascript:blur_rollover$4();" title="Downloads"><img src="/tt/skin/images/tab_itdownloads.gif" border="0" name="rollover$4" height="57" vspace="0" width="56"/></a><a href="/patterns/index.tss" onMouseOver="javascript:focus_rollover$5();" onMouseOut="javascript:blur_rollover$5();" title="Patterns"><img src="/tt/skin/images/tab_patterns.gif" border="0" name="rollover$5" height="57" vspace="0" width="50"/></a><a href="/reviews/index.tss" onMouseOver="javascript:focus_rollover$6();" onMouseOut="javascript:blur_rollover$6();" title="Reviews"><img src="/tt/skin/images/tab_reviews.gif" border="0" name="rollover$6" height="57" vspace="0" width="64"/></a><a href="/tt/articles/index.tss" onMouseOver="javascript:focus_rollover$7();" onMouseOut="javascript:blur_rollover$7();" title="Articles"><img src="/tt/skin/images/tab_articles_sel.gif" border="0" name="rollover$7" height="57" vspace="0" width="46"/></a>
</td>
        
      <td class="menuutilimages"><table cellspacing="0" class="borderless" align="right">
          <tr>
            <td class="divisor"><img src="/tt/images/spacer.gif" width="1" height="1"/></td>
                        
            <td class="formcontainer">
              <form class="search" action="/search.tss" >
                  <input size="15" type="text" name="q"/>
                  <button type="submit">Go</button>
              </form>
            </td>
            <td class="divisor"><img src="/tt/images/spacer.gif" width="1" height="1"/></td>

<td class="formcontainer">
<form method="post" name="Form0" action="/tt/tss" class="login">
<input type="hidden" name="service" value="direct/0/Article/border.login"/>
<input type="hidden" name="sp" value="S0"/>
<input type="hidden" name="Form0" value="inputEmail,inputPassword,callbackHidden"/>
<input type="hidden" name="callbackHidden" value="OH4sIAAAAAAAAAFvzloG1uIhBpiC_qCQxR68gMT21WM-xqCQzOSfVOTEnJykxOXtJq41BYf19SR4GhoqCEgZ-z7ySovyS_OCCosy8dCPTggoAkHQJkUUAAAA."/>

<input type="text" name="inputEmail" size="15"/>
<input type="password" name="inputPassword" maxlength="10" size="10"/>
 <button type="submit">Login</button>
                <br><span class="smalltext">661610
 members! <a href="/tt/user/signupemail.tss">Sign up</a> to stay informed.</span>
</form>


</td> <td class="divisor"><img src="/tt/images/spacer.gif" width="1" height="1"></td>
            <td><a href="/tt/rss/index.tss" onMouseOver="javascript:focus_feedsRollover();" onMouseOut="javascript:blur_feedsRollover();" title="RSS Feeds"><img src="/tt/skin/images/tab_feeds.gif" border="0" name="feedsRollover" height="57" width="56"/></a></td>
            <td class="divisor"><img src="/tt/images/spacer.gif" width="1" height="1"></td>
            <td><a href="/tt/common/about.tss" onMouseOver="javascript:focus_aboutRollover();" onMouseOut="javascript:blur_aboutRollover();" title="About ..."><img src="/tt/skin/images/tab_about.gif" border="0" name="aboutRollover" height="57" width="56"/></a></td>
          </tr>
        </table></td>
    </tr>
  </tbody>
</table>
<!--<table width="100%" border="0" cellspacing="0" cellpadding="0">
	<tr><td><img src="/tt/images/spacer.gif" width="868" height="1"></td></tr>
	<tr><td align="center" class="announcement"><span class="quiet">Attention:</span> Registration Is Open for the <a href="#">Third Annual O'Reilly Emerging Technology Conference.</a></td></tr>
</table>-->

<table class="layout" cellspacing="0" border="0">
    <tr>
      <td class="center" width="75%">
<table class="layout" cellspacing="0">
              <tr>

<td width="125">

<table>
 <tr>
    <td class="ad" width="120">


 <p><SPAN id='nointelliTXT'>

<!-- Text Ads ( ad-articles ) -->
 <div style="text-align:center;width:130px;padding-right:5px;" >
     
   <div class="adtitle" align="center">Sponsored Links<br /><br /></div>
                    
   <script type="text/javascript">          
        if ( typeof renderDartAd == "function" )   
            renderDartAd( /* textAdNumber */ 4,
                          /* adWidth */  125 ,
                          /* adHeight */ 100 ,
                          /* iHeight */  82 ,
                          /* adColor */  "FFFFFF",
                          /* showSpacer */ true,
                          /* startIndex */ 1);
   </script>
     
   <br />
   
<!-- Bitpipe Library-->
	<div class="adtitle" align="center">Resources<br /><br /></div>
	<div class="adtext" align="right" style="text-align:right;padding-right:5px;">
	  <a href="http://library.theserverside.com" onClick="return (true);">Enterprise Java<br />Research Library</a>
      <br />
	  Get Java white papers, product information, case studies and webcasts
    </div>
    
  <br />

<!-- Skyscrapper Ad -->
     <script type="text/javascript">          
        if ( typeof renderDartAd == "function" )   
            renderDartAd( /* textAdNumber */ 1,
                          /* adWidth */  120 ,
                          /* adHeight */ 600 ,
                          /* iHeight */  600 ,
                          /* adColor */  "FFFFFF");
    </script>
     
  </div>   

</SPAN>
</p> 
 </td>
  </tr>
 <tr>
    <td class="ad" width="120">


<SPAN id='nointelliTXT'>
   <script type="text/javascript">          
        if ( typeof renderDartAd == "function" )   
            renderDartAd( /* textAdNumber */ 1,
                          /* adWidth */ 125 ,
                          /* adHeight */ 138 ,
                          /* iHeight */ 138 ,
                          /* adColor */      "FFFFFF",
                          /* spacerBool */ false,
                          /* countStart */ 1 );
   </script> 
</SPAN> </td>
   </tr>  <tr>
        <td class="ad" width="120">

     
 </td>
    </tr>
    
</table>


</td>
<td><img height="1" src="/tt/images/spacer.gif" width="6"/></td>

<td width="*">


<br><img src="/tt/articles/content/IntrotoSpring25/IntrotoSpring25.gif" border="0" width="590" height="90"
alt="Introduction to the Spring Framework">

<br>
<br>

<b>October 2007</b>
<br>

<h2><b><a href="/news/thread.tss?thread_id=47267">Discussion</a></b></h2>
<br>
<br>
<p>Since I last revised this article in May, 2005, the Spring Framework has continued to grow in popularity, and has become the de facto standard for enterprise Java development. It has progressed from version 1.2 to the present 2.5, and has been adopted in an even wider range of industries and projects. In this article, I'll try to explain what Spring sets out to achieve, and how I believe it can help you to develop enterprise Java applications. </p>
<h2>Why Spring? </h2>
<p>I believe that Spring is unique, for several reasons: </p>
<ul>
  <li><strong>It addresses important areas that other popular frameworks don't</strong>. Spring focuses around providing a way to manage your business objects. </li>
  <li><strong>Spring is comprehensive and modular.</strong> Spring has a layered architecture, meaning that you can choose to use just about any part of it in isolation, yet its architecture is internally consistent. So you get maximum value from your learning curve. You might choose to use Spring only to simplify use of JDBC, for example, or you might choose to use Spring to manage all your business objects. And it's easy to introduce Spring incrementally into existing projects. </li>
  <li><strong>Spring is designed from the ground up to help you write code that's easy to test.</strong> Spring is an ideal framework for test driven projects. </li>
  <li><strong>Spring is an increasingly important integration technology</strong>, its role recognized by vendors large and small. </li>
  <li><strong>The Spring Framework is the core of the Spring Portfolio</strong> , an increasingly complete solution for enterprise Java development, exhibiting the same consistency of approach developed in the Spring Framework itself. </li>
</ul>
<p>Spring addresses most infrastructure concerns of typical applications. It also goes places other frameworks don't. </p>
<p>An open source project since February 2003, Spring has a long heritage. The open source project started from infrastructure code published with my book, <a href="http://www.wrox.com/books/0764543857.shtml" target="_blank">Expert One-on-One J2EE Design and Development</a>, in late 2002.<em> Expert One-on-One J2EE</em> laid out the basic architectural thinking behind Spring. However, the core architectural concepts go back to early 2000, and reflect my experience in developing infrastructure for a series of successful commercial projects. </p>
<p>There are now almost 40 developers, with the leading contributors devoted full-time to Spring development and support at Interface21. The flourishing open source community has helped it evolve into far more than could have been achieved by any individual. </p>
<h2>Architectural benefits of Spring </h2>
<p>Before we get down to specifics, let's look at some of the benefits Spring can bring to a project: </p>
<ul>
  <li><strong>Spring can effectively organize your middle tier objects</strong>. Spring takes care of plumbing that would be left up to you if you use only Struts or other frameworks geared to particular J2EE APIs. And Spring's configuration management services can be used in any architectural layer, in whatever runtime environment. </li>
  <li><strong>Spring can eliminate the proliferation of Singletons seen on many projects</strong>. In my experience, this is a major problem, reducing testability and object orientation. </li>
  <li><strong>Spring eliminates the need to use a variety of custom properties file formats</strong>, by handling configuration in a consistent way throughout applications and projects. Ever wondered what magic property keys or system properties a particular class looks for, and had to read the Javadoc or even source code? With Spring you simply look at the class's JavaBean properties or constructor arguments. The use of <strong>Inversion of Control</strong> and <strong>Dependency Injection</strong> (discussed below) helps achieve this simplification. </li>
  <li><strong>Spring facilitates good programming practice </strong>by reducing the cost of programming to interfaces, rather than classes, almost to zero. </li>
  <li><strong>Spring is designed so that applications built with it depend on as few of its APIs as possible</strong>. Most business objects in Spring applications have no dependency on Spring. </li>
  <li><strong>Applications built using Spring are very easy to test</strong>. For certain unit testing scenarios, the Spring Framework provides mock objects and testing support classes. Spring also provides unique &ldquo;integration testing&rdquo; functionality in the form of the Spring TestContext Framework and legacy JUnit 3.8 support classes that enable you to test your code quickly and easily, even while accessing a staging database. </li>
  <li><strong>Spring helps you solve problems with the most lightweight possible infrastructure</strong>. Spring provides an alternative to EJB that's appropriate for many applications. For example, Spring can use AOP to deliver declarative transaction management without using an EJB container; even without a JTA implementation, if you only need to work with a single database, or want to avoid two phase commit. </li>
  <li><strong>Spring provides a consistent framework for data access</strong>, whether using JDBC or an O/R mapping product such as TopLink, Hibernate or a JPA or JDO implementation. </li>
  <li><strong>Spring provides a consistent, simple programming model in many areas, making it ideal architectural &quot;glue.&quot;</strong> You can see this consistency in the Spring approach to JDBC, JMS, JavaMail, JNDI and many other important APIs. </li>
</ul>
<p><strong>Spring is essentially a technology dedicated to enabling you to build applications using Plain Old Java Objects (POJOs).</strong> It enables you to develop components as POJOs <em>containing only your business logic</em>, while the framework takes care of the many value adds you need to build enterprise applications &mdash; even in areas that you may not have considered when initially authoring the application. This goal requires a sophisticated framework, which conceals much complexity from the developer. Because your business logic is abstracted from infrastructure concerns, it&rsquo;s also likely to enjoy a longer life, improving the return on investment of writing it. Business logic should change at the pace of your business; only if it is abstracted from infrastructure concerns can the impact on your code base of inevitable infrastructure change (such as choice of application server) be minimized. </p>
<p>Thus Spring can enable you to implement the simplest possible solution to your problems. And that's worth a lot. </p>
<h2>What does Spring do? </h2>
<p>Spring provides a lot of functionality. So I'll quickly review each major area in turn. </p>
<p><strong>Mission</strong><strong> statement</strong></p>
<p>Spring's main aim is to make enterprise Java easier to use and promote good programming practice. It does this by enabling a POJO-based programming model that is applicable in a wide range of environments. We believe that Spring provides the ultimate programming model for modern enterprise Java. </p>
<p>Spring does not reinvent the wheel. Thus you'll find no logging packages in Spring, no connection pools, no distributed transaction coordinator. All these things are provided by open source projects (such as Commons Logging, which we use for all our log output, or Commons DBCP), or by your application server or web container. For the same reason, we don't provide an O/R mapping layer. There are good solutions to this problem such as TopLink, Hibernate, JPA and JDO. </p>
<p>Spring does aim to make existing technologies easier to use and does aim to provide a unified, simple yet powerful programming model. For example, although we are not in the business of low-level transaction coordination, we provide an abstraction layer over JTA or any other transaction strategy that is more portable, easier to use and makes code easier to test. </p>
<p>Spring benefits from internal consistency. All the developers are singing from the same hymn sheet, whose fundamental ideas remain faithful to those of <em>Expert One-on-One J2EE Design and Development</em>. And we've been able to use some central concepts, such as Inversion of Control, across multiple areas. </p>
<p>Spring is portable between application servers and web containers. (Indeed, its core functionality does not require another container.) Of course ensuring portability is always a challenge, but we avoid anything platform-specific or non-standard in the developer's view, and support users on WebLogic, Tomcat, Resin, JBoss, Jetty, Geronimo, WebSphere and other application servers. Spring's non-invasive, POJO approach enables us to take advantage of environment-specific features without sacrificing portability, as in the case of enhanced WebLogic, WebSphere and OC4J transaction management functionality that uses BEA and IBM proprietary APIs under the covers. </p>
<p><strong>Inversion of control container</strong></p>
<p>The core of Spring is the org.springframework.beans package, designed for working with POJOs. This package typically isn't used directly by users, but underpins much Spring functionality. </p>
<p>The next higher layer of abstraction is the <strong>bean factory</strong>. A Spring bean factory is a generic factory that enables configured objects to be retrieved by name, and which can manage relationships between objects. </p>
<p><em>A word on the term &ldquo;bean&rdquo;: very early versions of Spring were intended to configure only JavaBean objects. Since 1.0, Spring has been able to configure just about any Java object, regardless of whether it uses accessor and mutator methods, and in 2.5 it has become still more flexible. Nevertheless the term &ldquo;Spring Bean&rdquo; has remained common parlance. &ldquo;Spring-managed object&rdquo; is a more accurate term, conveying also the fact that Spring does not merely configure objects, but often continues to manage them at runtime -- for example, to apply enterprise services on every invocation</em><em>. </em></p>
<p>Bean factories support three modes of object lifecycle: </p>
<ul>
  <li><strong>Singleton</strong>: in this case, there's one shared instance of the object with a particular name, which will be retrieved on lookup. This is the default, and most often used, mode. It's ideal for stateless service objects. </li>
  <li><strong>Prototype</strong> or non-singleton: in this case, each retrieval will result in the creation of an independent object. For example, this could be used to allow each caller to have a distinct object reference. </li>
  <li><strong>Custom object &ldquo;scopes&rdquo;</strong>, which typically interact with a store outside the control of the container. Some of these come out of the box, such as request and session (for web applications). Others come with third party products, such as clustered caches. It is easy to define custom scopes in the event that none of those provided out of the box is sufficient, through implementing a simple interface. </li>
</ul>
<p>Because the Spring container manages relationships between objects, it can add value where necessary through services such as transparent pooling for managed POJOs, and support for hot swapping, where the container introduces a level of indirection that allows the target of a reference to be swapped at runtime without affecting callers and without loss of thread safety. One of the beauties of Dependency Injection (discussed shortly) is that all this is possible transparently, with no API involved. </p>
<p>As org.springframework.beans.factory.BeanFactory is a simple interface, it can be implemented in different ways. The BeanDefinitionReader interface separates the metadata format from BeanFactory implementations themselves, so the generic BeanFactory implementations Spring provides can be used with different types of metadata. You could easily implement your own BeanFactory or BeanDefinitionReader, although few users find a need to. The most commonly used BeanFactory definitions are: </p>
<ul>
  <li> XmlBeanFactory. This parses a simple, intuitive XML structure defining the classes and properties of named objects. </li>
  <li> DefaultListableBeanFactory: This provides the ability to parse bean definitions in properties files, and create BeanFactories programmatically. </li>
</ul>
<p>Each bean definition can be a POJO (defined by class name and JavaBean initialization properties or constructor arguments), or a FactoryBean. The FactoryBean interface adds a level of indirection. Typically this is used to create proxied objects using AOP or other approaches: for example, proxies that add declarative transaction management. This is conceptually similar to EJB interception, but works out much simpler in practice, and is more powerful. </p>
<p>BeanFactories can optionally participate in a hierarchy, &quot;inheriting&quot; definitions from their ancestors. This enables the sharing of common configuration across a whole application, while individual resources such as controller Servlets also have their own independent set of objects. </p>
<p>This motivation for the use of JavaBeans is described in Chapter 4 of <em><a href="http://www.theserverside.com/tt/articles/article.tss?l=RodJohnsonInterview">Expert One-on-One J2EE Design and Development</a></em>, which is available on the ServerSide as a free PDF. </p>
<p>Through its bean factory concept, Spring is an <strong>Inversion of Control</strong> container. (I don't much like the term <em>container</em>, as it conjures up visions of heavyweight containers such as EJB containers. A Spring BeanFactory is a container that can be created in a single line of code, and requires no special deployment steps.) Spring is most closely identified with a flavor of Inversion of Control known as <strong>Dependency Injection </strong><strong>&ndash; </strong>a name coined by Martin Fowler, Rod Johnson and the PicoContainer team in late 2003. </p>
<p>The concept behind Inversion of Control is often expressed in the <strong>Hollywood Principle</strong>: &quot;Don't call me, I'll call you.&quot; IoC moves the responsibility for making things happen into the framework, and away from application code. Whereas your code calls a traditional class library, an IoC framework calls your code. Lifecycle callbacks in many APIs, such as the setSessionContext() method for session EJBs, demonstrate this approach. </p>
<p>Dependency Injection is a form of IoC that removes explicit dependence on container APIs. Ordinary Java methods are used to <em>inject</em> dependencies such as collaborating objects or configuration values into application object instances. Where configuration is concerned this means that while in traditional container architectures such as EJB, a component might call the container to say &quot;where's object X, which I need to do my work&quot;, with Dependency Injection the <em>container</em> figures out that the component needs an X object, and provides it to it at runtime. The container does this figuring out based on method signatures (usually JavaBean properties or constructors) and, possibly, configuration data such as XML. </p>
<p>The two major flavors of Dependency Injection are <strong>Setter Injection</strong> (injection via JavaBean setters); and <strong>Constructor Injection</strong> (injection via constructor arguments). Spring provides sophisticated support for both, and even allows you to mix the two when configuring the one object. </p>
<p>As well as supporting all forms of Dependency Injection, Spring also provides a range of callback events, and an API for traditional lookup where necessary. However, we recommend a pure Dependency Injection approach in general. </p>
<p>Dependency Injection has important benefits. For example: </p>
<ul>
  <li>Because components don't need to look up collaborators at runtime, they're much simpler to write and maintain. In Spring's version of IoC, components express their dependency on other components via exposing JavaBean setter methods or through constructor arguments. For example, there is no need for JNDI lookups, which require the developer to write code that makes environmental assumptions. </li>
  <li>For the same reasons, application code is much easier to test. For example, JavaBean properties are simple, core Java and easy to test: simply write a self-contained JUnit or TestNG test method that creates the object and sets the relevant properties. </li>
  <li>A good IoC implementation preserves strong typing. If you need to use a generic factory to look up collaborators, you have to cast the results to the desired type. This isn't a major problem, but it is inelegant. With IoC you express strongly typed dependencies in your code and the framework is responsible for type casts. This means that type mismatches will be raised as errors when the framework configures the application; you don't have to worry about class cast exceptions in your code. </li>
  <li>Dependencies are explicit. For example, if an application class tries to load a properties file or connect to a database on instantiation, the environmental assumptions may not be obvious without reading the code (complicating testing and reducing deployment flexibility). With a Dependency Injection approach, dependencies are explicit, and evident in constructors or JavaBean properties. </li>
  <li>Most business objects don't depend on IoC container APIs. This makes it easy to use legacy code, and easy to use objects either inside or outside the IoC container. For example, Spring users often configure the Jakarta Commons DBCP DataSource as a Spring bean: there's no need to write any custom code to do this. We say that an IoC container isn't <strong>invasive</strong>: using it won't invade your code with dependency on its APIs. Almost any POJO can become a component in a Spring bean factory. Existing JavaBeans or objects with multi-argument constructors work particularly well, but Spring also provides unique support for instantiating objects from static factory methods or even methods on other objects managed by the IoC container. </li>
</ul>
<p>This last point deserves emphasis. Dependency Injection is unlike traditional container architectures, such as EJB, in this minimization of dependency of application code on a container. This means that your business objects can potentially be run in different Dependency Injection frameworks - or outside any framework - without code changes. </p>
<p>In my experience and that of Spring users, it's hard to overemphasize the benefits that IoC -- and, especially, Dependency Injection -- brings to application code. </p>
<p>Spring BeanFactories are very lightweight. Users have successfully used them inside applets, as well as standalone Swing applications. There are no special deployment steps and no detectable startup time associated with the container itself (although certain objects configured by the container may of course take time to initialize). This ability to instantiate a container almost instantly in any tier of an application can be very valuable. </p>
<p>The Spring BeanFactory concept is used throughout Spring, and is a key reason that Spring is so internally consistent. Spring is also unique among IoC containers in that it uses IoC as a basic concept throughout a full-featured framework. </p>
<p>Most importantly for application developers, one or more BeanFactories provide a well-defined layer of business objects. This is analogous to, but simpler (yet more powerful), than a layer of local session beans. Having a well-defined layer of business objects is very important to a successful architecture. </p>
<p>A Spring ApplicationContext is a subinterface of BeanFactory, which provides support for: </p>
<ul>
  <li>Message lookup, supporting internationalization </li>
  <li>An event mechanism, allowing application objects to publish and optionally register to be notified of events </li>
  <li>Automatic recognition of special application-specific or generic bean definitions that customize container behavior </li>
  <li>Portable file and resource access </li>
</ul>
<p><strong>XmlBeanFactory example</strong></p>
<p>Spring users traditionally configure their applications in XML &quot;bean definition&quot; files, although other forms of configuration, including source-level annotations, properties files and Java code, can also be used, and Spring will merge the results of the different configuration sources. </p>
<p>The root of a Spring XML bean definition document is a &lt;beans&gt; element. The &lt;beans&gt; element contains one or more &lt;bean&gt; definitions. We normally specify the class and properties of each bean definition. We normally also specify the id, which will be the name that we'll use this bean with in our code. </p>
<p>Let's look at a simple example, which configures three application objects with relationships commonly seen in enterprise Java applications: </p>
<ul>
  <li>A DataSource used to connect to a relational database </li>
  <li>A data access object (DAO) that uses the DataSource </li>
  <li>A business object that uses the DAO in the course of its work </li>
</ul>
<p>In the following example, we use a BasicDataSource from the Jakarta Commons DBCP project. ComboPooledDataSource from the C3PO project is also an excellent option. BasicDataSource, like many other existing classes, can easily be used in a Spring bean factory, as it offers JavaBean-style configuration. The close() method that needs to be called on shutdown can be registered via Spring's &quot;destroy-method&quot; attribute, to avoid the need for BasicDataSource to implement any Spring interface. </p>
<pre>&lt;beans>

  &lt;bean id="myDataSource"
	class="org.apache.commons.dbcp.BasicDataSource"
	destroy-method="close"
	p:driverClassName="com.mysql.jdbc.Driver"
	p:url="jdbc:mysql://localhost:3306/mydb"
	p:username="someone"/>
</pre>
<p>All the properties of BasicDataSource we're interested in are Strings, so we specify their values using the &quot;p:&quot; attribute prefix, a special, non-validated Spring namespace that allows the use of bean property names as XML attributes. This shortcut was introduced in Spring 2.0 as a convenient alternative to the &quot;value&quot; attribute or &lt;value&gt; subelement, which is usable even for values that are problematic in XML attributes. Spring uses the standard JavaBean PropertyEditor mechanism to convert String representations to other types if necessary. </p>
<p>Now we define the DAO, which has a bean reference to the DataSource. Relationships between beans are specified using a combination of the &quot;p:&quot; prefix and &quot;-ref&quot; suffix, the &quot;ref&quot; attribute, or the &lt;ref&gt; element: </p>
<pre>  &lt;bean id="exampleDataAccessObject"
	class="example.ExampleDataAccessObject"
	p:dataSource-ref="myDataSource"/>
</pre>
<p>The business object has a reference to the DAO, and an int property (exampleParam): </p>
<pre>&lt;bean id="exampleBusinessObject"	class="example.ExampleBusinessObject"
	p:dataAccessObject-ref="exampleDataAccessObject"
	p:exampleParam="10"/>

&lt;/beans>
</pre>
<p>Relationships between objects are normally set explicitly in configuration, as in this example. We consider this to be a Good Thing in most cases. However, Spring also provides two kinds of what we call &quot;autowire&quot; support, where it figures out the dependencies between beans: autowire by type, and autowire by name </p>
<p>The limitation with autowiring by type is that if there are multiple beans of a particular type it's impossible to work out which instance a dependency of that type should be resolved to. Unsatisfied dependencies are caught when the factory is initialized. (Spring also offers an optional dependency check for explicit configuration, which verifies that all properties have been set.) </p>
<p>This limitation in autowiring by type can often be overcome by autowiring by name. When using autowire by name, property names are used instead of types. For example, if a bean expresses a dependency by defining a setMaster method, Spring will try to find a bean with the name &quot;master&quot; within the BeanFactory and inject that bean to satisfy the dependency. While autowire by type works with either constructors or setter methods, autowire by name works automatically only with setter methods: a result of the fact that Java reflection does not expose the names of constructor or other method arguments. Spring 2.5 allows autowiring by name to be used for constructors via the @Qualifier parameter annotation. See the &ldquo;Beyond XML&rdquo; section below for further details. </p>
<p>We could use the autowire by type feature as follows in the above example, if we didn't want to code these relationships explicitly: </p>
<pre>&lt;bean id="exampleBusinessObject"
	class="example.ExampleBusinessObject"
	autowire="byType">

    &lt;property name="exampleParam" value="10" />
 &lt;/bean>
</pre>
<p>With this usage, Spring will work out that the dataSource property of exampleBusinessObject should be set to the implementation of DataSource it finds in the present BeanFactory. It's an error if there is none, or more than one bean of the required type in the present BeanFactory. We still need to set the exampleParam property, as it's not a reference. </p>
<p>Autowire support has the advantage of reducing the volume of configuration, especially when used as an optional attribute on the root &lt;beans&gt; element, which activates autowiring for all beans managed by Spring. It also means that the container learns about application structure using reflection, so if you add an additional constructor argument of JavaBean property, it may be successfully populated without any need to change configuration. The tradeoffs around autowiring should be evaluated carefully. </p>
<p>Externalizing relationships from Java code often has great benefit over hard coding them, as it's possible to change XML files without changing a line of Java code. For example, we could simply change the myDataSource bean definition to refer to a different bean class to use an alternative connection pool, or a test data source. We could use JNDI to get a data source from an application server in a single alternative XML stanza, as follows. There would be no impact on Java code or any other bean definitions. </p>
<pre>&lt;jee:jndi-lookup id="myDataSource" jndiName="jdbc/myDataSource" /></pre>
<p>Now let's look at the Java code for the example business object. Note that there are no Spring dependencies in the code listing below. A Spring IoC container is not invasive: you don't normally need to code awareness of it into application objects. </p>
<pre>public class ExampleBusinessObject implements MyBusinessObject {

	private ExampleDataAccessObject dao;
	private int exampleParam;

	public void setDataAccessObject(ExampleDataAccessObject dao) {
		this.dao = dao;
	}

	public void setExampleParam(int exampleParam) {
		this.exampleParam = exampleParam;
	}

	public void myBusinessMethod() {
		// do stuff using dao
	}
}
</pre>
<p>Note the property setters, which correspond to the XML references in the bean definition document. These are invoked by Spring before the object is used. </p>
<p>Such application beans do not need to depend on Spring. They don't need to implement any Spring interfaces or extend Spring classes: they just need to observe JavaBeans naming conventions. Reusing one outside of a Spring application context is easy, for example in a test environment. Just instantiate it with its default constructor, and set its properties manually, via setDataSource() and setExampleParam() calls. So long as you have a no-args constructor, you're free to define other constructors taking multiple properties if you want to support programmatic construction in a single line of code. </p>
<p>Note that the JavaBean properties are not declared on the business interface callers will work with. They're an implementation detail. We can easily &quot;plug in&quot; different implementing classes that have different bean properties without affecting connected objects or calling code. </p>
<p>Of course Spring bean factories have many more capabilities than described here, but this should give you a feel for the basic approach. As well as simple properties, and properties for which you have a JavaBeans PropertyEditor, Spring can handle lists, maps and java.util.Properties. Other advanced container capabilities include: </p>
<ul>
  <li><strong>Inner beans</strong>, in which a property element contains an anonymous bean definition not visible at top-level scope </li>
  <li><strong>Post processors</strong>: special bean definitions that customize container runtime behavior. These are simple to implement and provide an easy way of extending what Spring does out of the box. </li>
  <li><strong>Method Injection</strong>, a form of IoC in which the container implements an abstract method or overrides a concrete method to inject a dependency. This is a more rarely used form of Dependency Injection than Setter or Constructor Injection. However, it can be useful to avoid an explicit container dependency when looking up a new object instance for each invocation, or to allow configuration to vary over time--for example, with the method implementation being backed by a SQL query in one environment and a file system read in another. </li>
</ul>
<p>Bean factories and application contexts are often associated with a scope defined by an application server or web container, such as: </p>
<ul>
  <li><strong>A Servlet context</strong>. In the Spring MVC framework, an application context is defined for each web application containing common objects. Spring provides the ability to instantiate such a context through a listener or Servlet without dependence on the Spring MVC framework, so it can also be used in Struts, WebWork or other web frameworks. </li>
  <li><strong>A Servlet</strong>: Each controller Servlet in the Spring MVC framework has its own application context, derived from the root (application-wide) application context. It's also easy to accomplish this with Struts or another MVC framework. </li>
</ul>
<p>These hooks provided by the Java EE specifications generally avoid the need to use a Singleton to bootstrap a bean factory. </p>
<p>However, Spring can be used standalone, and it's trivial to instantiate a BeanFactory programmatically. For example, we could create the bean factory and get a reference to the business object defined above in the following two statements: </p>
<pre>XmlBeanFactory bf =
	new XmlBeanFactory(
		new ClassPathResource("myFile.xml", getClass()));
MyBusinessObject mbo =
	(MyBusinessObject) bf.getBean("exampleBusinessObject");
</pre>
<p>This code will work outside an application server: it doesn't even depend on Java EE, as the Spring IoC container is pure Java. The <strong>Spring Rich Client</strong> project (a framework for simplifying the development of Swing applications using Spring) demonstrates how Spring can be used outside a Java EE environment, as do Spring's integration testing features, discussed later in this article. Dependency Injection and the related functionality are too general and valuable to be confined to a Java EE, or server-side, environment. In fact, most of Spring's core concepts aren't even specific to Java and are also available in .NET environments with Spring.NET (<a href="http://www.springframework.net" target="_blank">http://www.springframework.net</a>), an application framework for the .NET platform. </p>
<p><strong>Custom XML </strong></p>
<p>Spring's XML configuration syntax is highly customizable. The spring-beans schema (<a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a>) is the most basic syntax and has traditionally been the most widely used. However, there are several common application artifacts whose configurations are largely identical, like JNDI object lookups. In these cases, Spring provides XML configuration extensions to enable essentially a domain-specific language (DSL) for configuration. This both reduces the amount of configuration and makes its intent much clearer.</p>
<p>Let's take a look at an example of configuring a DataSource obtained via JNDI lookup. Using the generic spring-beans schema, the bean declaration is as follows: </p>
<pre>&lt;bean id="dataSource"
class="org.springframework.jndi.JndiObjectFactoryBean">
&lt;property name="jndiName" value="jdbc/jpetsore" />
 &lt;/bean>
</pre>
<p>While this is much better than the Service Locator pattern, it still requires the user to know the name of the Spring class used for JNDI object lookups as well as its required properties. Further, this bean definition will be largely the same for all JNDI lookups, regardless of the type of the stored JNDI object.</p>
<p>One of the custom XML configuration extensions Spring provides out of the box is bound to the &quot;jee&quot; namespace, which allows us to express common tasks like JNDI lookups much more concisely: </p>
<pre>&lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/></pre>
<p>As you can see, the number of lines of configuration is less, there is less prior framework knowledge required, and the intent of the declaration is much clearer. Given that each of these XML configuration extensions is backed by an XML schema, modern IDEs with XML completion support make it immediately evident which attributes and elements are required versus optional.</p>
<p>Spring provides several namespaces out of the box including &quot;jee&quot; for Java EE-related configuration, &quot;aop&quot; for aspect-oriented configuration, and &quot;tx&quot; for transaction-related configuration. As mentioned previously, however, this is extensible; developers can define their own XML schemas to provide their own configuration DSLs. The XML configuration extensions that Spring provides out of the box are based on the same extension mechanism that developers can use themselves, and so provide good examples.</p>
<p>By providing a custom XML schema, an implementation of Spring's NamespaceHandler interface, and some simple Spring configuration in the form of two Java properties files (to register the custom namespace), Spring allows developers to create their own configuration DSLs that can create a single bean or any number of beans. Let's look at a simple example that will create a java.text.SimpleDateFormat bean.</p>
<p>The XML schema, provided by the developer, defines the structure of the custom XML configuration elements that are to be supported. Here it is for our example:</p>
<pre>&lt;xsd:schema xmlns="http://www.mycompany.com/schema/myns"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:beans="http://www.springframework.org/schema/beans"
    targetNamespace="http://www.mycompany.com/schema/myns"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified">

   &lt;xsd:import namespace="http://www.springframework.org/schema/beans"/>

   &lt;xsd:element name="dateformat">
      &lt;xsd:complexType>
         &lt;xsd:complexContent>
            &lt;xsd:extension base="beans:identifiedType">
               &lt;xsd:attribute name="lenient" type="xsd:boolean"/>
               &lt;xsd:attribute name="pattern" type="xsd:string" use="required"/>
            &lt;/xsd:extension>
         &lt;/xsd:complexContent>
      &lt;/xsd:complexType>
   &lt;/xsd:element>
&lt;/xsd:schema>
</pre>
<p>This is regular XML schema usage, serving to define the grammar for the custom element or elements.</p>
<p>Note the use of a convenient Spring base type called identifiedType (in bold) which means simply that the element will have an id attribute that will be used as the bean identifier in the container. This schema will allow us to use the following XML element in our Spring configuration: </p>
<pre>&lt;myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/>
</pre>
<p>Remember, we're only defining a shorter, more intention-revealing way of declaring a bean (or set of beans). We could still define this particular bean using conventional &lt;bean&gt; elements thus: </p>
<pre>&lt;bean id="dateFormat" class="java.text.SimpleDateFormat">
    &lt;constructor-arg value="yyyy-HH-dd HH:mm"/>
    &lt;property name="lenient" value="true"/>
&lt;/bean>
</pre>
<p>The difference is that the former is clearer and more intuitive to use than the latter, especially when using schema-aware editors. Now that our schema is done, let's take a look at implementing the NamespaceHandler interface.</p>
<p>The NamespaceHandler interface, implemented by the developer for each custom XML namespace, has just three methods.</p>
<ul>
  <li> init(), which allows for initialization of the NamespaceHandler and will be called by Spring before the handler is used. </li>
  <li> BeanDefinition parse(Element, ParserContext), which is called when Spring encounters a top-level element (not nested inside a bean definition or a different namespace). This method can register bean definitions itself and/or return a bean definition. </li>
  <li> BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext), which is called when Spring encounters an attribute or nested element of a different namespace. </li>
</ul>
<p>Often a custom namespace element will generate a single bean definition. In this simple case, the developer can simply subclass AbstractSingleBeanDefinitionParser and override two methods, getBeanClass(Element) and doParse(Element, BeanDefinitionBuilder) to provide the custom behavior. Here is how we would implement the example: </p>
<pre>public class SimpleDateFormatBeanDefinitionParser
  extends AbstractSingleBeanDefinitionParser {

   protected Class getBeanClass(Element element) {
      return SimpleDateFormat.class;
   }

   protected void doParse(
    Element element, BeanDefinitionBuilder bean) {
      // never null since the schema requires a value
      String pattern = element.getAttribute("pattern");
      bean.addConstructorArg(pattern);

      // this is an optional property
      String lenient = element.getAttribute("lenient");
      if (StringUtils.hasText(lenient)) {
         bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
      }
   }
}
</pre>
<p>That's all. The creation of our single BeanDefinition is handled by the AbstractSingleBeanDefinitionParser superclass, as is the extraction and setting of the bean definition's unique identifier.</p>
<p>Lastly, the namespace handler must be registered so that Spring knows about it while it's parsing the XML configuration. This is done by simply adding two Java properties files to the classpath, either in your application's jar or elsewhere. The first, called META-INF/spring.handlers, maps XML namespace URIs to namespace handler classes. The first part (the key) of each key-value pair is the URI associated with your custom namespace extension, and needs to match exactly the value of the 'targetNamespace' attribute as specified in your custom XSD schema:</p>
<pre># file META-INF/spring.handlers http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</pre>
<p>Note that the colon character (':') is a valid delimiter in the Java properties format, and so needs to be escaped with a backslash.</p>
<p>The second Java properties file that needs to be added is called META-INF/spring.schemas, and it maps the XML namespace URI to the actual schema document, which must be placed on the classpath, again either in your application's jar or elsewhere. In our example, it would look thus:</p>
<pre># file META-INF/spring.schemas
http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd
</pre>
<p>At this point, we've enabled our own application-specific syntax that makes it easier and clearer to express what would otherwise be much more verbose.</p>
<p>Spring&rsquo;s generic configuration serves most needs out of the box. Define your own custom namespaces only when one or more of the following applies:</p>
<ul>
  <li>You are defining beans of the same class repeatedly, and they typically have the same properties set each time. </li>
  <li>A group of beans must be defined together to work correctly, and hence configuration is naturally at a higher level of abstraction than bean by bean. </li>
  <li>You want to create a configuration DSL that will be reused widely across a project or company. </li>
  <li>You want the contribution of additional bean definitions to be conditional on existing bean definitions. A &lt;bean&gt; element defines exactly one bean definition; a NamespaceHandler can define zero or more bean definitions. </li>
  <li>You want to create an abstraction between configuration file and implementing class. A custom namespace conceals the class names of bean definitions, so if these change, configuration will not be broken. It is also possible to generate different class names in different runtime environments. </li>
</ul>
<p><strong>Beyond XML </strong></p>
<p>Spring aims to provide the ultimate configuration solution. Thus configuration does not need to be expressed in XML; Spring has its own powerful internal metadata format that is decoupled from any particular representation.</p>
<p>Since Spring 2.5, you can use Spring annotations or Java common annotations, defined by JSR-250 to configure your beans. By simply including a &lt;context:annotation-config/&gt; element in your application context's configuration, you can use these annotations not only on your property setter methods, but also on constructors, fields, and arbitrary methods and method parameters.</p>
<p>Here's an example using Spring's @Autowired annotation to configure a service bean that depends on a repository: </p>
<pre>// In file OrderServiceImpl.java:

public class OrderServiceImpl implements OrderService {
    private OrderRepository orderRepository;

    @Autowired
    public JdbcOrderServiceImpl(OrderRepository orderRepo) {
        this.orderRepository = orderRepo;
    }

    // ...
}

// In file JdbcOrderRepositoryImpl.java:

public class JdbcOrderRepositoryImpl implements OrderRepository {

    @Autowired
    @Qualifier("myDataSource")
    private DataSource orderDataSource;

    // ...
}
</pre>
<p>In the first class above, OrderServiceImpl, the @Autowired annotation indicates to Spring that this dependency should be injected by type via the constructor. In class JdbcOrderRepositoryImpl, the DataSource is injected by name; that is, as there may be multiple resources of type DataSource, the one with the bean name &quot;myDataSource&quot; will be the one provided. </p>
<p>In order to use JSR-250 common annotations in the example, simply replace @Autowired annotations with their @Resource equivalents: </p>
<pre>// In file JdbcOrderRepositoryImpl.java:

public class JdbcOrderRepositoryImpl implements OrderRepository {

    @Resource(name="myDataSource")
    private DataSource orderDataSource;

    // ...
}
</pre>
<p> @Resource always takes a value, and by default Spring will interpret that value as the bean name to be autowired. In other words, it follows by name semantics. The name provided with the annotation will be resolved as a bean name by the BeanFactory of which the CommonAnnotationBeanPostProcessor is aware. The names may be resolved via JNDI if Spring's <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jndi/support/SimpleJndiBeanFactory.html" target="_blank"> SimpleJndiBeanFactory</a> is configured explicitly; however, we recommend relying on the default behavior and simply using Spring's JNDI lookup capabilities to preserve the level of indirection. Thus, in the above example, the DataSource will be provided via a regular ApplicationContext lookup according to the name provided. </p>
<p>The @Autowired annotation can also be applied to arbitrary methods with any number of parameters, and Spring will treat such a method in a manner similar to constructor injection, supplying beans that match the method's parameters by type, and possibly by name via the @Qualifier annotation. For example: </p>
<pre>public class JdbcOrderRepositoryImpl implements OrderRepository {

    @Autowired
     public void init(
@Qualifier("myDataSource") orderDataSource,
@Qualifier("otherDataSource") inventoryDataSource,
MyHelper autowiredByType) {


    // ...
}
</pre>
<p>The method name is not significant. Multiple methods can be used in the one class (with the order of calling not guaranteed). &ldquo;Qualifiers&rdquo; can be associated with bean definitions like this: </p>
<pre>&lt;bean id="myDataSource" class="...">
  	&lt;qualifier value="order"/>
&lt;/bean>

&lt;bean id="otherDataSource" class="...">
  	&lt;qualifier value="inventory"/>
&lt;/bean>
</pre>
<p>Guice-style resolution by annotation is also fully supported, as in the following example: </p>
<pre>public class JdbcOrderRepositoryImpl implements OrderRepository {

    @Autowired
     public void setOrderServices(
@Emea OrderService emea,
@Apac OrderService apac) {


    // ...
}</pre>
<p>The annotations are associated with specific bean definitions through adding annotation qualifiers in the bean definitions, or through the use of the annotation on the target type itself.</p>
<p>This approach can lead to a profusion of annotation definitions, which are relatively verbose. However, it may be useful in some scenarios. Spring aims to provide a single container implementation that allows for any style of configuration (or a mix of styles) that the programmer prefers.</p>
<p>While this use of annotation-based autowiring is effective in reducing the amount of XML configuration, it still requires that each candidate bean be defined explicitly. To further reduce the required amount of XML configuration, you can make use of Spring's support for classpath scanning as a means to identify candidate beans. Spring provides @Component and @Repository &quot;stereotyping&quot; annotations that you can place on your candidate bean classes. By using the &lt;context:component-scan base-package=&quot;&hellip;&quot;&gt; configuration element, you tell Spring to automatically scan for and load as beans those classes in a given base package or its subpackages. This way, you won't have to declare each bean in your configuration &ndash; they will automatically be detected: </p>
<pre>package org.example.movies;

@Repository
public class JpaMovieFinder implements MovieFinder {
    // ...
}

&lt;beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-2.5.xsd"
>
    &lt;context:component-scan base-package="org.example"/>
&lt;/beans>
</pre>
<p>You can filter candidate class scanning at a more detailed level. The types of filter expressions that Spring supports include named annotations, classes that can be assigned to particular interfaces or superclasses, regular expressions, and AspectJ pointcut expressions. Further, you can specify including patterns, excluding patterns, or both.</p>
<p>For example, in a test environment, the following configuration tells Spring to scan the classpath for any stub repositories in org.example and its subpackages, ignoring any classes found therein annotated with @Repository: </p>
<pre>&lt;beans ...>
    &lt;context:component-scan base-package="org.example">
        &lt;context:include-filter type="regex"
            expression=".*Stub.*Repository"/>
        &lt;context:exclude-filter type="annotation"
            expression="org.springframework.stereotype.Repository"/>
    &lt;/context:component-scan></pre>
<p>Annotations and classpath scanning make for an effective way to eliminate substantial XML configuration.</p>
<p>As a developer, Spring allows you the choice of the perfect configuration option for each task &ndash; notably:</p>
<ul>
  <li><strong>Annotations in Java code</strong>, when you don&rsquo;t anticipate wiring changing frequently </li>
  <li><strong>XML configuration files</strong>, when wiring is likely to change without recompilation, or you want to use the power of custom namespaces </li>
  <li><strong>Properties files</strong>, to move simple configuration properties into the simplest possible format. </li>
</ul>

<p>Don&rsquo;t forget that you can also use the new operator to create objects in Java code: just because you have an IoC container doesn&rsquo;t mean that the new operator no longer works! </p>

<p><strong>JDBC abstraction and data access exception hierarchy</strong></p>
<p>Data access is another area in which Spring shines. </p>
<p>JDBC offers fairly good abstraction from the underlying database, but is a painful API to use. Some of the problems include: </p>
<ul>
  <li>The need for verbose error handling to ensure that ResultSets, Statements and (most importantly) Connections are closed after use. This means that correct use of JDBC can quickly result in a lot of code. It's also a common source of errors. Connection leaks can quickly bring applications down under load. </li>
  <li>The relatively uninformative SQLException. Traditionally JDBC does not offer an exception hierarchy, but throws an SQLException in response to all errors. Finding out what actually went wrong - for example, was the problem a deadlock or invalid SQL? - involves examining the SQLState value and error code. The meaning of these values varies between databases. </li>
</ul>
<p>Spring addresses these problems in two ways: </p>
<ul>
  <li>By providing APIs that move tedious and error-prone exception handling out of application code into the framework. The framework takes care of all exception handling; application code can concentrate on issuing the appropriate SQL and extracting results. </li>
  <li>By providing a meaningful exception hierarchy for your application code to work with in place of SQLException. When Spring first obtains a connection from a DataSource it examines the metadata to determine the database product. It uses this knowledge to map SQLExceptions to the correct exception in its own hierarchy descended from org.springframework.dao.DataAccessException. Thus your code can work with meaningful exceptions, and need not worry about proprietary SQLState or error codes. Spring's data access exceptions are not JDBC-specific, so your DAOs are not necessarily tied to JDBC because of the exceptions they may throw. </li>
</ul>
<p>The following UML class diagram illustrates a part of this data access exception hierarchy, indicating its sophistication. Note that none of the exceptions shown here is JDBC-specific. There are JDBC-specific subclasses of some of these exceptions, but calling code is generally abstracted wholly away from dependence on JDBC: an essential if you wish to use truly API-agnostic DAO interfaces to hide your persistence strategy. <br>
    <img width="916" height="397" src="/tt/articles/content/IntrotoSpring25/clip_image001.gif"></p>
<p>The Spring JDBC core org.springframework.jdbc.core package uses callbacks to move control - and hence error handling and connection acquisition and release - from application code to inside the framework. This is a different type of Inversion of Control, but equally valuable to that used for configuration management. </p>
<p>Spring uses a similar callback approach to address several other APIs that involve special steps to acquire and cleanup resources, such as JDO (acquiring and relinquishing a PersistenceManager), JPA (same but for EntityManager), transaction management (using JTA) and JNDI. Spring classes that perform such callbacks are called <em>templates</em>. </p>
<p>For example, the Spring SimpleJdbcTemplate object can be used to perform a SQL query and save the results in a list as follows: </p>
<pre>SimpleJdbcTemplate template = new SimpleJdbcTemplate(dataSource);
List<String> names = template.query("SELECT USER.NAME FROM USER",
	new ParameterizedRowMapper<String>() {
		public String mapRow(ResultSet rs, int rowNum) throws SQLException;
			return rs.getString(1);
		}
	});
</pre>
<p>The mapRow callback method will be invoked for each row of the ResultSet. </p>
<p>Application code within the callback is free to throw SQLException: Spring will catch any exceptions and rethrow them in its own hierarchy. The application developer can choose which exceptions, if any, to catch and handle. </p>
<p>The SimpleJdbcTemplate provides many methods to support different scenarios including prepared statements and batch updates. Simple tasks like running SQL functions can be accomplished without a callback, as follows. The example also illustrates the use of bind variables: </p>
<pre>int youngUserCount = template.queryForInt("SELECT COUNT(0) FROM USER WHERE USER.AGE &lt; ?", 25);</pre>
<p>The Spring JDBC abstraction has a very low performance overhead beyond standard JDBC, even when working with huge result sets. (In one project in 2004, we profiled the performance of a financial application performing up to 1.2 million inserts per transaction. The overhead of Spring JDBC was minimal, and the use of Spring facilitated the tuning of batch sizes and other parameters. This application now powers all interbank transfers in the world&rsquo;s fourth largest economy.) </p>
<p>The org.springframework.jdbc.object package contains the StoredProcedure class. By extending this class, Spring enables a stored procedure to be proxied by a Java class with a single business method. If you like, you can even define an interface that the stored procedure implements, meaning that you can free your application code from depending on the use of a stored procedure at all. </p>
<p>For example, if there were a stored procedure called &quot;AllTitles&quot; in a movie database to get all of the titles currently available, we would create a StoredProcedure subclass that implements an application-specific interface for use by clients. </p>
<pre>public class AllTitleSproc
    extends StoredProcedure
    implements AllTitleLister {

    private static final String STORED_PROCEDURE_NAME = "AllTitles";
    private static final String RESULT_SET_NAME = "titles";

    public AllTitleSproc(DataSource dataSource) {
        setDataSource(dataSource);
        setSql(STORED_PROCEDURE_NAME);
        declareParameter(
            new SqlReturnResultSet(
                RESULT_SET_NAME, new TitleMapper()));
        compile();
    }

    public List&lt;Title> listAllTitles() {
        Map result = execute(new HashMap()); // no input params
        return (List&lt;Title>) result.get(RESULT_SET_NAME);
    }

    private static class TitleMapper
        implements ParameterizedRowMapper&lt;Title> {
        public Title mapRow(ResultSet resultSet, int i)
            throws SQLException {

            Title t = new Title(resultSet.getLong(1));
            t.setName(resultSet.getString(2));
            return t;
        }
    }
}
</pre>
<p>Notice first that we can achieve portability with stored procedures across databases; all that is required is that the stored procedure name be the same (although we could make this configurable if we wanted in order to further increase portability). Second, notice that the class AllTitleSproc implements an application-specific interface, AllTitleLister: </p>
<pre>public interface AllTitleLister {
    List&lt;Title> listAllTitles();
}
</pre>
<p>This allows code that uses this functionality to be completely independent of how movie titles are obtained: </p>
<pre>public class AllTitleListerClient {

    private AllTitleLister allTitleLister;

    public void setAllTitleLister(AllTitleLister allTitleLister) {
        this.allTitleLister = allTitleLister;
    }

    public void useLister() {
        List&lt;Title> titles = allTitleLister.listAllTitles();
        for (Title t : titles) {
            System.out.println(t.getId() + ":" + t.getName());
        }
    }
</pre>
<p>Since the allTitleLister property is provided via dependency injection, this client code only depends upon the interface and none of its implementation details. </p>
<p>The Spring data access exception hierarchy is based on unchecked (runtime) exceptions. Although controversial at first, time has shown that this was the right decision. </p>
<p>Data access exceptions not usually recoverable. For example, if we can't connect to the database, a particular business object is unlikely to be able to work around the problem. One potential exception is optimistic locking violations, but not all applications use optimistic locking. It's usually bad to be forced to write code to catch fatal exceptions that can't be sensibly handled. Letting them propagate to a top-level handler like a Servlet container is usually more appropriate. All Spring data access exceptions are subclasses of DataAccessException, so if we do choose to catch all Spring data access exceptions, we can easily do so. </p>
<p>If we <em>do</em> want to recover from an unchecked data access exception, we can still do so. We can write code to handle only the recoverable condition. For example, if we consider that only an optimistic locking violation is recoverable, we can write code in a Spring DAO as follows: </p>
<pre>try {
	// do work
}
catch (OptimisticLockingFailureException ex) {
	// I'm interested in this
}
</pre>
<p>If Spring data access exceptions were checked, we'd need to write the following code. Note that we could <em>choose</em> to write this anyway: </p>
<pre>try {
	// do work
}
catch (OptimisticLockingFailureException ex) {
	// I'm interested in this
}
catch (DataAccessException ex) {
	// Fatal; just rethrow it
}
</pre>
<p>One potential objection to the first example - that the compiler can't enforce handling the potentially recoverable exception - applies also to the second. Because we're forced to catch the base exception ( DataAccessException), the compiler won't enforce a check for a subclass ( OptimisticLockingFailureException). So the compiler would force us to write code to handle an unrecoverable problem, but provide no help in forcing us to deal with the recoverable problem. </p>
<p>Spring's use of unchecked data access exceptions is consistent with that of many - probably <em>most</em> - successful persistence frameworks. (Indeed, it was partly inspired by JDO, and has in turn influenced several other products.) JDBC is one of the few data access APIs to use checked exceptions. TopLink and JDO, for example, use unchecked exceptions exclusively. Hibernate switched from checked to unchecked exceptions in version 3. </p>
<p>Spring JDBC can help you in several ways: </p>
<ul>
  <li>You'll never need to write a finally block again to use JDBC </li>
  <li>Connection leaks will be a thing of the past </li>
  <li>You'll need to write less code overall, and that code will be clearly focused on the necessary SQL </li>
  <li>You'll never need to dig through your RDBMS documentation to work out what obscure error code it returns for a bad column name. Your application won't be dependent on RDBMS-specific error handling code. </li>
  <li>Whatever persistence technology use, you'll find it easy to implement the DAO pattern without business logic depending on any particular data access API. </li>
  <li>You'll benefit from improved portability (compared to raw JDBC) in advanced areas such as BLOB handling and invoking stored procedures that return result sets. </li>
</ul>
<p>All this amounts to substantial productivity gains and fewer bugs. I used to loathe writing JDBC code; now I find that I can focus on the SQL I want to execute, rather than the incidentals of JDBC resource management. </p>
<p>Spring's JDBC abstraction can be used standalone if desired - you are not forced to use the other parts of Spring. </p>
<p><strong>O/R mapping integration</strong></p>
<p>Of course often you want to use O/R mapping (ORM), rather than use relational data access. Your overall application framework must support this also. Thus, Spring integrates out of the box with the JPA 1 and JDO 1 and 2 specifications, as well as Hibernate (versions 2 and 3), TopLink, iBatis and other ORM products. Its data access architecture allows it to integrate with <em>any</em> underlying data access technology. </p>
<p>Why would you use an ORM product plus Spring, instead of the ORM product directly? Spring adds significant value in the following areas: </p>
<ul>
  <li><strong>Session management</strong>. Spring offers efficient, easy, and safe handling of units of work such as JPA EntityManagers, <em>in any runtime environment</em>. Related code using the ORM tool alone generally needs to use the same EntityManager for efficiency and proper transaction handling. Spring can transparently create and bind one to the current thread, using either a declarative, AOP method interceptor approach, or by using an explicit, &quot;template&quot; wrapper class at the Java code level. Thus Spring solves many of the usage issues that affect many users of ORM technology. </li>
  <li><strong>Resource management</strong>. Spring application contexts can handle the location and configuration of JPA EntityManagerFactories, JDBC datasources, and other related resources. This makes these values easy to manage and change. </li>
  <li><strong>Integrated transaction management</strong>. Spring allows you to wrap your ORM code with either a declarative, AOP method interceptor, or an explicit 'template' wrapper class at the Java code level. In either case, transaction semantics are handled for you, and proper transaction handling (rollback, etc.) in case of exceptions is taken care of. As we discuss later, you also get the benefit of being able to use and swap various transaction managers, without your ORM-related code being affected. As an added benefit, JDBC-related code can fully integrate transactionally with ORM code, in the case of most supported ORM tools. This is useful for handling functionality not amenable to ORM. </li>
  <li><strong>Exception wrapping, as described above</strong>. Spring can wrap exceptions from the ORM layer, converting them from proprietary (possibly checked) exceptions, to a set of abstracted runtime exceptions. This allows you to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without annoying boilerplate catch-throw blocks and exception declarations. You can still trap and handle exceptions anywhere you need to. Remember that JDBC exceptions (including DB specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model. </li>
  <li><strong>To avoid vendor lock-in</strong>. ORM solutions have different performance and other characteristics, and there is no perfect one size fits all solution. Alternatively, you may find that certain functionality is just not suited to an implementation using your ORM tool. Thus it makes sense to decouple your architecture from the tool-specific implementations of your data access object interfaces. If you ever need to switch to another implementation for reasons of functionality, performance, or any other concerns, using Spring now can make the eventual switch much easier. Spring's abstraction of your ORM tool's Transactions and Exceptions, along with its IoC approach which allow you to easily swap in mapper/DAO objects implementing data-access functionality, make it easy to isolate all ORM-specific code in one area of your application, without sacrificing any of the power of your ORM tool. The PetClinic sample application shipped with Spring demonstrates the portability benefits that Spring offers by providing variants that use JDBC, Hibernate, TopLink and Apache OJB to implement the persistence layer. </li>
  <li><strong>Ease of testing</strong>. Spring's inversion of control approach makes it easy to swap the implementations and locations of resources such as JPA EntityManagerFactories, datasources, transaction managers, and mapper object implementations (if needed). This makes it much easier to isolate and test each piece of persistence-related code in isolation. </li>
</ul>
<p>Above all, Spring facilitates a mix-and-match approach to data access. ORM is <em>not</em> the solution to all problems, although it is a valuable productivity win in many cases. Spring enables a consistent architecture, and transaction strategy, even if you mix and match persistence approaches, with or without JTA. </p>
<p>In cases where ORM is not ideally suited, Spring's simplified JDBC is not the only option: the &quot;mapped statement&quot; approach provided by <a href="http://www.ibatis.com/common/sqlmaps.html">iBATIS SQL Maps</a> is worth a look. It provides a high level of control over SQL, while still automating the creation of mapped objects from query results. Spring integrates with SQL Maps out of the box. Spring's PetStore sample application illustrates iBATIS integration. </p>
<p><strong>Transaction management</strong></p>
<p>Abstracting a data access API is not enough; we also need to consider transaction management. JTA is the obvious solution, but it's a cumbersome API to use directly, and as a result many J2EE developers used to feel that EJB CMT is the only rational option for transaction management. Spring has changed that. </p>
<p>Spring provides its own abstraction for transaction management. Spring uses this to deliver: </p>
<ul>
  <li>Programmatic transaction management via a callback template analogous to the SimpleJdbcTemplate, which is much easier to use than straight JTA </li>
  <li>Declarative transaction management analogous to EJB CMT, but without the need for an EJB container. Actually, as we'll see, Spring's declarative transaction management capability is a semantically compatible superset of EJB CMT, with some unique and important benefits. </li>
</ul>
<p>Spring's transaction abstraction is unique in that it's not tied to JTA or any other transaction management technology. Spring uses the concept of a <strong>transaction strategy</strong> that decouples application code from the underlying transaction infrastructure (such as JDBC). It offers a superset of the capabilities of JTA, supporting simulation of nested transactions using savepoints in savepoint-capable resources, and allowing control over isolation level. </p>
<p>Why should you care about this? Isn't JTA the best answer for all transaction management? If you're writing an application that uses only a single database, you don't need the complexity of JTA. You're not interested in XA transactions or two phase commit. You may not even need a high-end application server that provides these things. But, on the other hand, you don't want to have to rewrite your code should you ever have to work with multiple data sources. </p>
<p>Imagine you decide to avoid the overhead of JTA by using JDBC or JPA EntityTransactions directly. If you ever need to work with multiple data sources, you'll have to rip out all that transaction management code and replace it with JTA transactions. This isn't very attractive and led most authors on Java EE to recommend using global JTA transactions exclusively, effectively ruling out using a web container such as Tomcat for transactional applications. Using the Spring transaction abstraction, however, you only have to reconfigure Spring to use a JTA, rather than JDBC or JPA, transaction strategy and you're done. This is a configuration change, not a code change. Thus, <strong>Spring enables you to write applications that can scale down as well as up</strong>. </p>
<p><strong>AOP</strong></p>
<p>Among other things, AOP provides a proven, flexible solution to addressing cross-cutting enterprise concerns, such as transaction management, which were traditionally addressed by EJB. </p>
<p>The first goal of Spring's AOP support is to provide J2EE services to POJOs. Spring AOP is portable between application servers, so there's no risk of vendor lock in. It works in either web or EJB containers, and has been used successfully in WebLogic, Tomcat, JBoss, Resin, Jetty, Orion and many other application servers and web containers. </p>
<p>Spring AOP supports method interception. Key AOP concepts supported include: </p>
<ul>
  <li><strong>Interception</strong>: Custom behavior can be inserted before or after method invocations against any interface or class. This equates to &ldquo;before&rdquo;, &ldquo;after&rdquo; and &quot;around advice&quot; in AspectJ terminology. </li>
  <li><strong>Introduction</strong>: Specifying that an advice should cause an object to implement additional interfaces. This can amount to mixin inheritance. </li>
  <li>Static and dynamic <strong>pointcuts</strong>: Specifying the points in program execution at which interception should take place. Static pointcuts concern method signatures; dynamic pointcuts may also consider method arguments at the point where they are evaluated. Pointcuts can be reused. </li>
</ul>
<p>Spring implements AOP using dynamic proxies (where an interface exists) or CGLIB byte code generation at runtime (which enables proxying of classes). Both approaches work in any application server, or in a standalone environment. </p>
<p>Spring integrates with AspectJ, providing the ability to seamlessly include AspectJ aspects into Spring applications . Since Spring 1.1 it has been possible to dependency inject AspectJ aspects using the Spring IoC container, just like any Java class. Thus AspectJ aspects can depend on any Spring-managed objects. The integration with the AspectJ 5 is exciting, as AspectJ provides the ability to dependency inject any non Spring-managed POJO using Spring, based on XML or annotation-driven pointcuts. </p>
<p>Since Spring 2.0, Spring can also use the AspectJ pointcut expression language to specify pointcuts or matching rules. This is very beneficial, as AspectJ offers much richer semantics, and greater type safety, than simplistic pure interception solutions. It also means that the same aspects can be written for use in Spring and AspectJ: two different runtime choices--one simple, powerful, programming model. </p>
<p>Because Spring advises objects at instance, rather than class loader, level, it is possible to use multiple instances of the same class with different advice, or use unadvised instances along with advised instances. </p>
<p>Perhaps the commonest use of Spring AOP is for declarative transaction management. This builds on the transaction abstraction described above, and can deliver declarative transaction management on any POJO. Depending on the transaction strategy, the underlying mechanism can be JTA, JDBC, Hibernate or any other API offering transaction management. </p>
<p>The following are the key differences from EJB CMT: </p>
<ul>
  <li>Transaction management can be applied to any POJO. We recommend that business objects implement interfaces, but this is a matter of good programming practice, and is not enforced by the framework. </li>
  <li>Programmatic rollback can be achieved within a transactional POJO through using the Spring transaction API. We provide static methods for this, using ThreadLocal variables, so you don't need to propagate a context object such as an EJBContext to ensure rollback. </li>
  <li>You can define <strong>rollback rules</strong> declaratively. Whereas EJB 2.1 and earlier will not automatically roll back a transaction on an uncaught application exception (only on unchecked exceptions, other types of Throwable and &quot;system&quot; exceptions), application developers often want a transaction to roll back on any exception. Spring transaction management allows you to specify declaratively which exceptions and subclasses should cause automatic rollback&mdash;at a per method (or use case) level, rather than the more coarse grained per exception level offered by EJB 3.0. Default behavior is as with EJB, but you can specify automatic rollback on checked, as well as unchecked exceptions. This has the important benefit of minimizing the need for programmatic rollback, which creates a dependence on the Spring transaction API. </li>
  <li>Because the underlying Spring transaction abstraction supports savepoints if they are supported by the underlying transaction infrastructure, Spring's declarative transaction management can support <strong>nested</strong> transactions, in addition to the propagation modes specified by EJB CMT (which Spring supports with identical semantics). Thus, for example, if you are performing JDBC operations on Oracle, you can use declarative nested transactions using Spring. </li>
  <li>Transaction management is not tied to JTA. As explained above, Spring transaction management can work with different transaction strategies. </li>
</ul>
<p>It's also possible to use Spring AOP to implement application-specific aspects. Whether or not you choose to do this depends on your level of comfort with AOP concepts, rather than Spring's capabilities, but it can be very useful. Successful examples we've seen include: </p>
<ul>
  <li>Custom security checks, where the complexity of security checks required is beyond the capability of the standard JEE security infrastructure. Of course, before rolling your own security infrastructure, you should check the capabilities of Spring Security (formerly <a href="http://acegisecurity.sourceforge.net/">Acegi Security for Spring</a>), a powerful, flexible security framework that integrates with Spring using AOP, and reflects Spring's architectural approach. </li>
  <li>Debugging and profiling aspects for use during development </li>
  <li>Aspects that apply consistent exception handling policies in a single place </li>
  <li>Interceptors that send emails to alert administrators or users of unusual scenarios </li>
</ul>
<p>Application-specific aspects can be a powerful way of removing the need for boilerplate code across many methods. </p>
<p>Spring AOP integrates transparently with the Spring IoC container. Code obtaining an object from a Spring BeanFactory doesn't need to know whether or not it is &ldquo;advised&rdquo;&mdash;that is, whether any aspects apply to it (or &ldquo;advise&rdquo; it). As with any object, the contract will be defined by the interfaces the object implements. </p>
<p>Performance monitoring, auditing or tracing is one of the many areas where Spring AOP can be used along with AspectJ 5's pointcut expression language. To monitor invocations of service methods, we can use the following style of configuration: </p>
<pre>&lt;bean id="performanceMonitor" class="com.example.PerformanceMonitor"/>

&lt;aop:config>
  &lt;aop:aspect ref="performanceMonitor">
    &lt;aop:around
      pointcut="execution(public * com.example.Service+.*(..))"
      method="monitor" />
  &lt;/aop:aspect>
&lt;/aop:config>
</pre>
<p>The above declaration causes the POJO class com.example.PerformanceMonitor's &quot;monitor&quot; method to be called wherever any public method in the class com.example.Service or its subclasses would have been called. The monitor method can start a timer, allow execution to proceed as normally (via proceed() on org.aspectj.lang.ProceedingJoinPoint), then stop the timer after proceed() returns, record the time taken, then return the proxied method's return value: </p>
<pre>public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
    long start = System.nanoTime();
    try {
        return pjp.proceed();
    } finally {
        long time = System.nanoTime() - start;
        // do something with time...
    }
}
</pre>
<p>We can also use the &ldquo;@AspectJ &ldquo; style of programming introduced in AspectJ 5, where the annotation is included in the aspect class itself, as follows, This is appropriate and elegant when the matching rule (or pointcut) is closely linked to the aspect implementation: </p>
<pre>@Around("execution(public * com.example.Service+.*(..))")
public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
    long start = System.nanoTime();
    try {
        return pjp.proceed();
    } finally {
        long time = System.nanoTime() - start;
        // do something with time...
    }
}
</pre>
<p>Automatic application of such aspects (when defined as Spring beans) is enabled through the following XML tag: </p>
<pre>&lt;aop:aspectj-autoproxy /></pre>
<p>There are a number of ways to set up proxying concisely, if you don't need the full power of the AOP framework, such as using Java 5.0 annotations to drive transactional proxying without XML metadata. </p>
<p>The following example illustrates the simplest way to use Spring AOP to perform transaction management for a POJO. First, define a business interface: </p>
<pre>public interface AccountService {
    Account createAccount(String name);
}
</pre>
<p>The transaction management-related portion of the Spring configuration is now reduced to the following (assuming JPA is used with DataSource &quot;myDataSource&quot;): </p>
<pre>&lt;bean id="transactionManager"
	class="org.springframework.orm.jpa.JpaTransactionManager">
	p:dataSource-ref="myDataSource"/>

&lt;tx:annotation-driven/>
</pre>
<p>Given the above example, any invocations to the service's &quot;createAccount&quot; method will actually be on a Spring transaction manager that implements the AccountService interface. The proxy will begin or join a transaction (since the default transaction propagation setting is REQUIRED), will allow execution to proceed through the JpaAccountServiceImpl's &quot;createAccount&quot; method implementation, and the transaction will commit or rollback appropriately based on the exit of the method. The @Transactional attribute can be used on types or methods. </p>
<p>Spring also automatically supports EJB&rsquo;s @TransactionAttribute: however, note that the semantics of this are less rich than @Transactional. </p>
<p>While it's also possible to construct AOP proxies programmatically without using a BeanFactory, although this is more rarely used. We believe that it's generally best to externalize the wiring of applications from Java code, and AOP is no exception. </p>
<p><strong>MVC web framework</strong></p>
<p>Spring includes a powerful and highly configurable MVC web framework. </p>
<p>Spring's MVC model is most similar to that of Struts, although it is not derived from Struts. A Spring Controller is similar to a Struts Action in that it is a multithreaded service object, with a single instance executing on behalf of all clients. However, we believe that Spring MVC has some significant advantages over Struts. For example: </p>
<ul>
  <li>Spring provides a clean division between controllers, JavaBean models, and views. </li>
  <li>Spring's MVC is very flexible. Unlike Struts, which forces your Action and Form objects into concrete inheritance (thus taking away your single shot at concrete inheritance in Java), Spring MVC is entirely based on interfaces. Furthermore, just about every part of the Spring MVC framework is configurable via plugging in your own interface. Of course we also provide convenience classes as an implementation option. </li>
  <li>Spring provides <strong>interceptors</strong> as well as controllers, making it easy to factor out behavior common to the handling of many requests. </li>
  <li>Spring MVC is truly view-agnostic. You don't get pushed to use JSP if you don't want to; you can use Velocity, XLST or other view technologies. If you want to use a custom view mechanism - for example, your own templating language - you can easily implement the Spring View interface to integrate it. </li>
  <li>Spring Controllers are configured via IoC like any other objects. This makes them easy to test, and beautifully integrated with other objects managed by Spring. </li>
  <li>Spring MVC web tiers are typically easier to test than Struts web tiers, due to the avoidance of forced concrete inheritance and explicit dependence of controllers on the dispatcher servlet. </li>
  <li>The web tier becomes a thin layer on top of a business object layer. This encourages good practice. Struts and other dedicated web frameworks leave you on your own in implementing your business objects; Spring provides an integrated framework for all tiers of your application. </li>
</ul>
<p>As in Struts 1.1 and above, you can have as many dispatcher servlets as you need in a Spring MVC application. </p>
<p>The following example shows how a simple Spring Controller can access business objects defined in the same application context. This controller looks up an Order and returns it in its handleRequest() method: </p>
<pre>public class OrderController
		implements Controller {

	private OrderRepository repo;

	@Autowired
	public OrderController(OrderRepository orderRepository) {
		repo = orderRepository;
	}

	public ModelAndView handleRequest(
		HttpServletRequest request,
		HttpServletResponse response)
	throws ServletException, IOException
	{
		String id = request.getParameter("id");
		Order order = repo.getOrderById(id);
		return new ModelAndView("orderView", "order", order);
	}
}
</pre>
<p>Spring IoC isolates this controller from the underlying OrderRepository; it could be based on JDBC just as much as it could be a web service. The interface could equally be implemented by a plain Java object, test stub, mock object, or proxy to a remote object. This controller contains no resource lookup; nothing except code necessary to support its web interaction. </p>
<p>Spring MVC also provides support for data binding, forms, wizards and more complex workflow. However, if you require sophisticated conversation management, you should consider <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW/Home" target="_blank">Spring Web Flow</a>, a powerful framework that provides a higher level of abstraction for web flows than any traditional web MVC framework. </p>
<p>A good introduction to the Spring MVC framework is Thomas Risberg's Spring MVC tutorial (<a href="http://www.springframework.org/docs/MVC-step-by-step/Spring-MVC-step-by-step.html" target="_blank">http://www.springframework.org/docs/MVC-step-by-step/Spring-MVC-step-by-step.html</a>). See also &quot;Web MVC with the Spring Framework&quot; (<a href="http://www.springframework.org/docs/web_mvc.html" target="_blank">http://www.springframework.org/docs/web_mvc.html</a>). </p>
<p>If you're happy with your favorite web framework, Spring's layered infrastructure allows you to use the rest of Spring without our MVC layer. We have Spring users who use Spring for middle tier management and data access but use Struts, WebWork, Tapestry or JSF in the web tier. </p>
<p><strong>Testing</strong></p>
<p>As you've probably gathered, I and the other Spring developers are firm believers in the importance of comprehensive unit and integration testing. We believe that it's essential that frameworks are thoroughly unit tested, and that a prime goal of framework design should be to make applications built on the framework easy to unit test. </p>
<p>Spring itself has an excellent unit test suite. We've found the benefits of test first development to be very real on this project. For example, it has made working as an internationally distributed team extremely efficient, and users comment that CVS snapshots tend to be stable and safe to use. </p>
<p>Applications built on Spring are very easy to test, for the following reasons: </p>
<ul>
  <li>IoC facilitates unit testing </li>
  <li>Applications don't contain plumbing code directly using Java EE services such as JNDI, which is typically hard to test </li>
  <li>Spring bean factories or contexts can be set up outside a container </li>
</ul>
<p>The ability to set up a Spring bean factory outside a container offers interesting options for the development process. Work can begin by defining business interfaces and integration testing their implementation outside a web container. Only after business functionality is substantially complete is a thin layer added to provide a web interface. </p>
<p>Spring provides powerful and unique support for a form of integration testing outside the deployed environment. This is not intended as a substitute for unit testing or testing against the deployed environment. However, it can significantly improve productivity. </p>
<p>The Spring Framework provides first class support for integration testing in the form of the classes packaged in the spring-test.jar library. In this library, you will find the org.springframework.test package which contains valuable classes for integration testing using a Spring container, which do not require an application server or other deployment environment. Such tests can run in JUnit or TestNG &ndash; even in an IDE &ndash; without any special deployment step. They will be slower to run than unit tests but much faster to run than the equivalent Cactus tests or remote tests relying on deployment to an application server. Typically it is possible to run hundreds of tests hitting a development database &ndash; usually <em>not</em> an embedded database, but the product used in production &ndash; within seconds, rather than minutes or hours. Such tests can very quickly verify correct wiring of your Spring contexts, and data access using JDBC or ORM tool, such as correctness of SQL statements. For example, you can test your DAO implementation classes. </p>

<p>Prior to the 2.5 release of the framework, Spring provided integration testing support specific to JUnit 3.8. As of the 2.5 release, Spring offers support for unit and integration testing in the form of the <em>Spring TestContext Framework</em>, which is agnostic of the actual testing framework in use, thus allowing instrumentation of tests in various environments including JUnit 3.8, JUnit 4.4, TestNG, etc. The Spring TestContext Framework requires Java 5 or higher. </p>

<p>The Spring team recommends using the Spring TestContext Framework for all new integration testing involving ApplicationContexts or requiring transactional test fixtures; however, if you are developing in a pre-Java 5 environment, you will need to continue to use the JUnit 3.8 legacy support. </p>

<p>The Spring integration testing support frameworks share several common goals, including: </p>
<ul>
  <li>The ability to <strong>cache container configuration between test cases</strong>, which greatly increases performance where slow-to-initialize resources such as JDBC connection pools or Hibernate SessionFactories are concerned. </li>
  <li>The ability to <strong>populate test fixture instances via Dependency Injection</strong>. This makes it possible to reuse Spring XML configuration when testing and eliminates the need for custom setup code for tests. </li>
  <li>Infrastructure to <strong>create a transaction around each test method</strong> and roll it back at the conclusion of the test by default. This makes it possible for tests to perform any kind of data access without worrying about the effect on the environments of other tests. In my experience across several complex projects using this functionality, the productivity and speed gain of such a rollback-based approach is very significant. </li>
  <li>Spring-specific <strong>support classes</strong> that are really useful when writing integration tests. </li>
</ul>
<p>For details outlining each of these goals, please consult the revised &quot;Testing&quot; </p>
<p>chapter of the Spring reference manual. </p>
<p>For example, in the following revised PetClinic example (which is based on the example included in the Spring distribution in samples/petclinic), we define integration tests in an abstract class that is configured with annotations provided by the <em>Spring TestContext Framework</em>. This class &ndash; which is essentially a POJO, thanks to the use of SpringJUnit4ClassRunner &ndash; is configured to provide some extremely convenient features, like automatically injecting dependencies, rolling back transactions at the end of each test, and reusing the configuration bootstrapped via Spring during the test setup (thanks to the fact that we're rolling back after each test, restoring the environment to the same initial state). </p>
<pre>@RunWith(SpringJUnit4ClassRunner.class)
@TestExecutionListeners({
DependencyInjectionTestExecutionListener.class,
TransactionalTestExecutionListener.class})
@Transactional
@ContextConfiguration(
locations={"applicationContext-dataSourceCommon.xml"})
public abstract class AbstractClinicTests {

	// dependency injected by Spring
@Autowired
	protected Clinic clinic;

	// test that runs in transactional context with rollback
	@Test
	public void testFindOwners() {
		Collection&lt;?> owners = this.clinic.findOwners("Davis");
		assertEquals(2, owners.size());
		owners = this.clinic.findOwners("Daviss");
		assertEquals(0, owners.size());
	}

	// more tests...
}
</pre>
<p>Now that we've defined our abstract tests, we can simply subclass it for use with specific technologies and run them as simple JUnit 4.4 tests. Here's the first one, using straight JDBC: </p>
<pre>@ContextConfiguration(locations={"applicationContext-jdbc.xml"})
public class JdbcClinicTests extends AbstractClinicTests {}
</pre>
<p>Note that for this example, JdbcClinicTests does not contain a single line of code: we only need to supply the correct locations to @ContextConfiguration, and the tests are inherited from AbstractClinicTests. The relevant portions of the Spring configuration file, applicationContext-jdbc.xml, are shown here (the bean named &quot; dataSource&quot; is defined in applicationContext-dataSourceCommon.xml): </p>
<pre>&lt;bean id="transactionManager"
    class="...jdbc.datasource.DataSourceTransactionManager"
    p:dataSource-ref="dataSource"/>

&lt;bean class="...samples.petclinic.jdbc.HsqlJdbcClinic"
    p:dataSource-ref="dataSource"/>
</pre>
<p>All that we need to in this configuration file is define our &quot;transactionManager&quot; bean as a simple Spring DataSourceTransactionManager, our Clinic implementation bean as our own HsqlJdbcClinic, and Spring takes care of the rest. We can simply execute JdbcClinicTests as a regular JUnit 4.4 test class, and Spring will configure our environment, run each test method in its own transaction, and roll back the transaction after each test! </p>
<p>To test a different implementation of Clinic that uses Hibernate, we simply change our configuration to use a HibernateTransactionManager and our own HibernateClinic. </p>
<p>Here is the Hibernate-based JUnit 4.4. test class: </p>
<pre>@ContextConfiguration(locations={"applicationContext-hibernate.xml"})
public class HibernateClinicTests extends AbstractClinicTests {}
</pre>
<p>And the relevant the configuration file &quot; applicationContext-hibernate.xml&quot;: </p>
<pre>&lt;!--
    Hibernate "sessionFactory" bean defined here for use
    with the HSQL "dataSource" bean and HSQL dialect
-->

&lt;bean id="transactionManager"
    class="...orm.hibernate3.HibernateTransactionManager"
    p:sessionFactory-ref="sessionFactory"/>

&lt;bean class="...samples.petclinic.hibernate.HibernateClinic"
    p:sessionFactory-ref="sessionFactory"/>
</pre>
<p>The above examples could just as easily have been implemented with JUnit 3.8 or TestNG. The Spring TestContext Framework thus allows developers to leverage the unit testing framework most suitable to their project and team. </p>
<p>As you can see, the benefits of using Spring at testing time are significant. </p>
<p><strong>Who's using Spring?</strong></p>
<p>There are thousands of production applications using Spring. Users include investment and retail banking organizations, well-known dotcoms, global consultancies, academic institutions, government departments, defense contractors, several airlines, and scientific research organizations (including CERN). Some examples: </p>
<ul>
  <li>Voca, Europe's largest processor of direct debit &amp; credit transactions, uses Spring heavily in a system that processes billions of payments per year. The introduction to Spring helped drive a significant gain in developer productivity, and Spring plays an important role in processing each of over 80 million payment instructions daily. Interface21's expertise was instrumental in the architecture of Voca&rsquo;s core payment engine.<br>
  </li>
  <li>eSpaceNet, the European patent office's online patent database, is responsible for managing all patents across the continent of Europe. Spring's web application development solutions have improved productivity, enhanced performance, and reduced maintenance costs.<br>
  </li>
  <li>Sabre Airlines Solutions, the leading provider of airline information systems, uses Spring throughout their next-generation aircraft control system. </li>
  <li>Accenture, one of the world&rsquo;s leading SIs, uses Spring extensively in client engagements and best practice solutions. Accenture has also contributed to the Spring Portfolio through collaborating with Interface21 to create the Spring Batch project. </li>
  <li>Nine out of the top 10 global banks use Spring extensively in Java applications. Several have standardized on Spring to structure their applications. </li>
</ul>
<p>Interestingly, although the first version of this article was published six months before the release of Spring 1.0 final, almost all the code and configuration examples would still work unchanged in today's 2.5 release. We are proud of our excellent record on backward compatibility. This demonstrates the ability of Dependency Injection and AOP to deliver a non-invasive API, and also indicates the seriousness with which we take our responsibility to the community to provide a stable framework to run vital applications. </p>
<h2>Summary </h2>
<p>Spring is a powerful framework that solves many common problems in enterprise Java. Most Spring features are also usable in a wide range of Java environments, beyond classic Java EE. </p>
<p>Spring provides a consistent way of managing business objects and encourages good practices such as programming to interfaces, rather than classes. The architectural basis of Spring is an Inversion of Control container designed to configure any POJO. However, this is only part of the overall picture: Spring is unique in that it uses its IoC container as the basic building block in a comprehensive solution that addresses all architectural tiers. </p>
<p>Spring provides a unique data access abstraction, including a simple and productive JDBC framework that greatly improves productivity and reduces the likelihood of errors. Spring's data access architecture also integrates with TopLink, Hibernate, JDO, JPA and other O/R mapping solutions. </p>
<p>Spring also provides a unique transaction management abstraction, which enables a consistent programming model over a variety of underlying transaction technologies, such as JTA or JDBC. </p>
<p>Spring provides an AOP framework written in standard Java, which provides declarative transaction management and other enterprise services to be applied to POJOs or - if you wish - the ability to implement your own custom aspects. This framework is powerful enough to enable many applications to dispense with the complexity of EJB, while enjoying key services traditionally associated with EJB. </p>
<p>Spring also provides a powerful and flexible MVC web framework that is integrated into the overall IoC container. Numerous other enterprise services, such as remoting and JMX integration, are offered out of the box, but are beyond the scope of this article. </p>
<p><strong>Spring and Java versions </strong></p>

<p>While many new features (such as annotation-based programming styles) require Java features introduced in version 5.0, as of Spring 2.5, all core functionality is still available in applications using Java 1.4. This is important to users of older application servers, who do not need to upgrade their production environments to take advantage of a productive modern programming model. </p>

<p>New Java 6-specific features include: </p>

<ul>
  <li> JDBC 4.0: Jdbc4NativeJdbcExtractor, support for extended DataSource interface </li>
  <li> JMX MXBean support: server-side export and client-side proxying of MXBeans </li>
  <li> ServiceLoader API: making services discovered via META-INF/services available for dependency injection </li>
  <li> JAX-WS support: including support for service exposure via the built-in web server in JDK 1.6 </li>
</ul>
<p><strong>The future </strong></p>

<p> One of the key benefits of Dependency Injection is that your code can not merely be configured in an environment it does not depend on explicitly, but can benefit from services that were not envisaged at its time of authoring. Thus Spring offers a flexible component model that can offer a variety of value adds for little or no effort. For example: </p>

<ul>
  <li> You can &ldquo;export&rdquo; any Spring-managed object as a JMX MBean without writing Java code </li>
  <li> Spring Dynamic Modules for OSGi&trade; Service Platforms allows Spring to take advantage of the powerful modularization capabilities of OSGi, without business objects needing to depend on OSGi APIs or an OSGi runtime. </li>
  <li> Spring&rsquo;s compatibility with the SCA SOA standard makes Spring managed objects &ldquo;SCA ready&rdquo;. SCA specifies a Spring binding for Java. </li>
  <li> Spring integrates with a range of clustering and grid solutions such as GigaSpaces, Oracle Coherence and Terracotta. </li>
  <li> Your code can take advantage of Spring&rsquo;s rich and deepening range of platform integrations, while remaining free of proprietary extensions. For example, in a WebLogic environment, you gain sophisticated transaction monitoring functionality due to the fact that Spring ties into BEA APIs, without writing a line of WebLogic-specific code in your application. </li>
</ul>

<p> Spring moves forward rapidly, and development activity is further accelerating, so the range of value adds available continues to grow. </p>

<p><strong>More information</strong></p>
<p>See the following resources for more information about Spring: </p>
<ul>
  <li>Interface21 offers Spring training courses worldwide - <a href="http://www.interface21.com/training" target="_blank">http://www.interface21.com/training</a>. </li>
  <li><a href="http://www.wrox.com/books/0764543857.shtml" target="_blank">Expert One-on-One J2EE Design and Development</a> (Rod Johnson, Wrox, 2002). Although Spring has evolved and improved significantly since the book's publication, it's still an excellent place to go to understand Spring's motivation. </li>
  <li><a href="http://www.wrox.com/books/0764558315.shtml" target="_blank">J2EE without EJB</a> (Rod Johnson with Juergen Hoeller, Wrox, 2004). Sequel to <em>J2EE Design and Development</em> that discusses the rationale for Spring and the lightweight container architecture it enables. </li>
  <li>The<a href="http://static.springframework.org/spring/docs/2.5.x/reference/index.html" target="_blank"> Spring Reference Manual</a>. The printable form is over 500 pages as of Spring 2.5. Spring also ships with several sample applications that illustrate best practices and can be used as templates for your own applications. </li>
  <li><a href="http://www.apress.com/book/bookDisplay.html?bID=405" target="_blank">Pro Spring</a>: In-depth Spring coverage by core developer Rob Harrop. </li>
  <li>Spring Framework home page: <a href="http://www.springframework.org/" target="_blank">http://www.springframework.org/</a>. This includes Javadoc and several tutorials. </li>
  <li><a href="http://forum.springframework.org/" target="_blank">User forums</a></li>
  <li>Spring-developer <a href="http://sourceforge.net/mail/?group_id=73357" target="_blank">mailing list</a>. </li>
  <li>Interface21 offers production and development support for Spring: http://www.interface21.com/support. </li>
</ul>
<p>We pride ourselves on excellent response rates and a helpful attitude to queries on the forums and mailing lists. We hope to welcome you into our community soon! </p>
<p><strong>About the Author</strong></p>
<p><strong>Rod Johnson</strong> , the founder of Spring, has over ten years experience as a Java developer and architect and has worked with J2EE since the platform emerged. He is the author of the best-selling <em>Expert One-on-One J2EE Design and Development</em> (Wrox, 2002), and <em>J2EE without EJB</em> (Wrox, 2004, with Juergen Hoeller) and has contributed to several other books on J2EE. Rod serves on several Java specification committees including Java EE 6, and is a regular conference speaker. Rod is CEO of <a href="http://www.interface21.com">Interface21</a>, the company that leads and sustains Spring. Interface21 provides production and development support, training and consultancy for Spring. </p>
<p>Thanks also to Matthew Adams and Sam Brannen of Interface21. </p>


<P AlIGN="CENTER">
<a href="/tt/articles/content/IntrotoSpring25/article.html">PRINTER FRIENDLY VERSION</a>
<BR>
<img src="/tt/images/tss_white.gif" align="center">
</P>

<!-- 
YOU MUST CHANGE THE variable "google_ad_channel" at the bottom of this page 
to be one of the following values depending on the page type : 

	news
	discussions
	techtalks
	patterns
	reviews
	articles
	other

-->

<!-- Begin AdSense -->
<script>
<!--
function ss(w){window.status=w;return true;}
function cs(){window.status='';}
function ga(o,e){
	if (document.getElementById){
		a=o.id.substring(1);
		p="";
		g=e.target;
			if(g){
				t=g.id;f=g.parentNode;
					if(f)p=f.id;
				}
			else{t=e.srcElement.id;}
				if(t==a||p==a)return;location.href=document.getElementById(a).href
	}
}
//-->
</script>


<style type="text/css">
 .ch{cursor:pointer;cursor:hand}
</style>

<script language="JavaScript">
<!--
function google_ad_request_done(google_ads) {
var i;
var header;
accip = "off";

if(google_ads.length > 0) {

		document.write('<table cellspacing="0" class="box">');
		document.write('<thead>');
		document.write('    <tr>');
		document.write('        <th><img src="/tt/skin/images/bar_begin.gif" width="8" height="18"/>');
		document.write('<span class="container"><span class="text">Related Links</span><span class="shadow">Related Links</span></span><span class="fill">Related Links</span> </th>');
		document.write('     </td>');
		document.write('    </tr>');
		document.write('   <tr>');
		document.write('       <td class="barbottom"><img src="/tt/images/spacer.gif" width="10" height="10"/></td>');
		document.write('   </tr>');
		document.write('</thead>');
    
		document.write('<tbody>');
		document.write('  <tr>');
		document.write('      <td>');
		document.write('          <table cellspace="2"> ');
		document.write('<tr>');
		document.write('              <td><span class="text"><b>Ads by Google</b></span>');
		document.write('              </td>');
		document.write('</tr>');

    	for(i = 0; i < google_ads.length; ++i) {
			document.write('<TR><td width="100%" onClick="window.open(\'' + google_ads[i].url + '\',\'_blank\')" style="cursor:pointer; cursor:hand" onMouseOver="return ss(\'' + google_ads[i].visible_url + '\')" onMouseOut="cs()">');
			document.write('<A HREF="#marketplace_top"><b>');
			document.write(google_ads[i].line1);
			document.write('</b></a><br>');
			document.write(' ' + google_ads[i].line2 + ' ');
			document.write(' ' + google_ads[i].line3 + ' ');
			document.write('<br>');
			document.write('<h2><A HREF="#marketplace_top">' + google_ads[i].visible_url + '</a></h2>');
			document.write('              </td>');
			document.write('</tr>');
		
		}
	
		document.write('	</table>');
		document.write('          </td>');
		document.write('          </tr>');
		document.write('</tbody>');
		document.write('</table>');
	}
}
// -->
</script>

<script language="JavaScript">
<!--
   var      google_ad_client = 'ca-techtargetserver_js';
   var      google_ad_channel = 'articles';
   var      google_ad_output = 'js';
   var      google_max_num_ads = 5;
// -->
</script>

<A NAME="marketplace_top"></A>
<script language="JavaScript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>

</td>


</tr>
          </table>

     </td>
   </tr>
</table>

<hr/>

<div class="center">
  <span class="smalltext">
<a href="/news/index.tss">News</a> |
<a href="/blogs/index.tss">Blogs</a> |
<a href="/discussions/index.tss">Discussions</a> |
<a href="/talks/index.tss">Tech talks</a> |
<a href="/patterns/index.tss">Patterns</a> |
<a href="/reviews/index.tss">Reviews</a> |
<a href="http://library.theserverside.com/">White Papers</a> |
<a href="http://library.theserverside.com/itdownloads/">Downloads</a> |
<a href="/tt/articles/index.tss">Articles</a> |
<a href="mailto:bmcgovern@techtarget.com">Media kit</a> |

<a href="/tt/common/about.tss">About</a> </span>
</div>

<div class="center">
	<span class="smalltext">

<a href="http://javasolutions.theserverside.com">Java Solutions</a>	</span>
</div>

<div class="center">
  <span class="smalltext">All Content Copyright &copy;2007 TheServerSide <a target="_blank" href="http://www.techtarget.com/html/privacy_policy.html">Privacy Policy</a></span>
</div>

<div class="center">
	<span class="smalltext">

<a href="http://www.theserverside.com/sitemap.html">Site Map</a>	</span>
</div>



</body>
</html>
<!-- Render time: ~ 13 ms -->

